<?xml version="1.0" encoding="utf-8"?>
<chapter
	version="5.0"
	xml:id="chapter.database_connection_objects"
	xml:lang="en"
	xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:db="http://docbook.org/ns/docbook"
	>
	
	<title>Database Connection Objects</title>
	
	<section>
		<title>What is a Connection Object?</title>
		
		<para>
			A connection object is an object managing a connection to the database.
			The connection is wrapped in that object and the object provides methods which interacts with the database
			and it also contains a few convenience methods.
		</para>
		
		<para>
			RapidDataMapper has separate objects handling the specific interactions with the database.
			This provides a separate layer of abstraction, which can easily be swapped to provide support for another database.
		</para>
		
		<para>
			The database connection objects are managed by the <classname>Db</classname> class, a combination of the flyweight and singleton pattern.
			This because it only allows one instance per configuration, but several instances per class
			(because it allows several connections using the same driver).
		</para>
		
		<para>
			If you use the <glossterm>Object-Relational-Mapper</glossterm> you will probably not use this layer directly in most cases.
		</para>
	</section>
	
	<section>
		<title>Fetching a Connection Object</title>
		
		<para>
			The Connection objects are instantiated when they are requested.
			All the requests are made by calling <function>Db::getConnection()</function> which will return the
			connection instance after it has been instantiated (if it already is instantiated it will simply return
			the already instantiated object).
		</para>
		
		<funcsynopsis xml:id="funcref.Db-getConnection">
			<funcprototype>
				<funcdef><type>Db_Connection</type> <function>Db::getConnection</function></funcdef>
				
				<paramdef choice="opt"><type>string</type> <parameter>$name</parameter> = 'default'</paramdef>
			</funcprototype>
		</funcsynopsis>
		
		<example>
			<title>Fetching a Connection Object</title>
			
			<programlisting language="php"><![CDATA[// fetching the default connection
$default_connection = Db::getConnection();

// fetching a specific connection:
$foo_connection = Db::getConnection('foo');]]></programlisting>
		</example>
		
		<para>
			You can change the name of the default connection using
			<function linkend="funcref.Db-setDefaultConnectionName">Db::setDefaultConnectionName()</function>.
		</para>
	</section>
	
	<section>
		<title>Querying the database using a Connection Object</title>
		
		<para>
			Querying the database using the <classname>Db_Connnection</classname> objects
			is pretty straightforward: call <function>Db_Connection->query()</function> with
			the SQL as the first parameter:
		</para>
		
		<example>
			<title>Performing a basic query</title>
			
			<programlisting language="php"><![CDATA[$db = Db::getConnection();

$result = $db->query('SELECT * FROM users');

foreach($result as $row)
{
	// ...
}]]></programlisting>
		</example>
		
		<funcsynopsis xml:id="funcref.Db_Connection-query">
			<funcprototype>
				<funcdef><type>Db_Result</type>|<type>int</type> <function>Db_Connection->query</function></funcdef>
				
				<paramdef><type>string</type> <parameter>$SQL</parameter></paramdef>
				<paramdef choice="opt"><type>associative array</type> <parameter>$binds</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
		
		<para>
			The return values differ depending on the type of query: read queries (SELECT and its relatives)
			make <function>Db_Connection->query()</function> return <type>Db_Result</type> objects,
			write queries (INSERT, UPDATE, DELETE and similar) make it return an <type>int</type> which contains the number of modified rows.
		</para>
		
		<example>
			<title>Performing an UPDATE query and checking for modified rows</title>
			
			<programlisting language="php"><![CDATA[$db = Db::getConnection();

// 0 == false, so if 0 rows were modified, the condition below will fail
if($db->query('UPDATE users SET name = "foobar" WHERE id = 2'))
{
	echo 'UPDATE successful!';
}
else
{
	echo 'UPDATE failed';
}]]></programlisting>
		</example>
	</section>
	
	<section xml:id="chapter.database_connection_objects.Db_Result">
		<title>Db_Result objects, the database return objects</title>
		
		<para>
			Database results are returned wrapped in <classname>Db_Result</classname> objects
			which contain methods for interacting with the database <type>resource</type> and
			fetching its data.
			<classname>Db_Result</classname> implements <classname>IteratorAggregate</classname> and
			<classname>Countable</classname> making it behave a bit like an array at the same time it
			is an object (and it also enables a few performance improvements).
		</para>
		
		<para>
			By default the returned rows are <classname>stdClass</classname> objects which has
			the column names as the property names. Arrays can also be fetched, but objects are
			a slightly bit faster to fetch.
		</para>
		
		<example>
			<title>Basic Db_Result usage</title>
			
			<programlisting language="php"><![CDATA[$result = Db::getConnection()->query('SELECT * FROM tracks');

echo 'Number of rows: '.count($result);

// Using it as an iterator:
foreach($result as $row)
{
	echo $row->name;
}]]></programlisting>
		</example>
		
		<para>
			If you would like to get the result as an array of arrays, you can use <function>Db_Result->resultArray()</function>:
		</para>
		
		<example>
			<title>Getting arrays of arrays as results</title>
			
			<programlisting language="php"><![CDATA[$result = Db::getConnection()->query('SELECT * FROM tracks');

$array = $result->resultArray();]]></programlisting>
		</example>
		
		<example>
			<title>Fastest iteration using the Db_Result</title>
			
			<para>
				The fastest iteration is made using <function>Db_Result->next()</function>:
			</para>
			
			<programlisting language="php"><![CDATA[$result = Db::getConnection()->query('SELECT * FROM tracks');

while($row = $result->next())
{
	echo $row->name;
}]]></programlisting>
			
			<para>
				It is only marginally faster when iterating, so the slower iteration
				using <classname>IteratorAggregate</classname> is recommended as it is easier to read and understand.
			</para>
		</example>
	</section>
	
	<section xml:id="chapter.database_connection_objects.database_drivers">
		<title>Database Drivers</title>
		
		<para>
			
		</para>
	</section>
</chapter>