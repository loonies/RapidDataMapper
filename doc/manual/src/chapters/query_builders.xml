<?xml version="1.0" encoding="utf-8"?>
<chapter
	version="5.0"
	xml:id="chapter.query_builders"
	xml:lang="en"
	xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:db="http://docbook.org/ns/docbook"
	>
	
	<title>Query Builders</title>
	
	<section>
		<title>Query builders at a glance</title>
		
		<para>
			The query builders are a set of PHP classes which generate <acronym>SQL</acronym>.
			These classes contain methods which manipulate the final output,
			making it possible to easily tailor a query dynamically without
			fear of malformed <acronym>SQL</acronym> or compromised security. 
		</para>
		
		<para>
			The classes, starting with <classname>Db_Query_*</classname> are responsible
			for one type of query each: SELECT (
			<classname linkend="chapter.query_builders.select_queries">Db_Query_Select</classname>),
			INSERT (<classname linkend="chapter.query_builders.insert_queries">Db_Query_Insert</classname>),
			UPDATE (<classname linkend="chapter.query_builders.update_queries">Db_Query_Update</classname>) and
			DELETE (<classname linkend="chapter.query_builders.delete_queries">Db_Query_Delete</classname>)
		</para>
		
		<para>
			The benefits of using query builders are several:
		</para>
		
		<itemizedlist>
			<listitem>
				<para>
					Automatic escaping and protection from <acronym>SQL</acronym> injection attacks and other SQL-vulnerabilities.
				</para>
			</listitem>
			
			<listitem>
				<para>
					You can easily manipulate queries before executing them,
					no need to perform complex string building or to call escaping methods all the time.
				</para>
			</listitem>
			
			<listitem>
				<para>
					Almost no risk of executing malformed SQL.
				</para>
			</listitem>
		</itemizedlist>
		
		<para>
			A few drawbacks:
		</para>
		
		<itemizedlist>
			<listitem>
				<para>
					A small loss of performance when generating the queries.
				</para>
			</listitem>
			
			<listitem>
				<para>
					The query builders cannot create all types of <acronym>SQL</acronym>.
				</para>
			</listitem>
		</itemizedlist>
	</section>
	
	<section>
		<title>Generic Usage</title>
		
		<para>
			The different query builders work very alike, they differ in a few key points
			in the same way that the different query types differ between each other.
		</para>
		
		<section>
			<title>Getting a query builder object</title>
			
			<para>
				To get a query builder object, you call a specific method on the
				<classname linkend="chapter.database_connection_objects">Db_Connection</classname> object(s):
			</para>
			
			<section>
				<title>SELECT query builder object</title>
				
				<funcsynopsis xml:id="funcref.Db_Connection-select">
					<funcprototype>
						<funcdef><type>Db_Query_Select</type> <function>Db_Connection->select</function></funcdef>
						
						<paramdef choice="opt"><type>mixed</type> <parameter>$columns</parameter></paramdef>
					</funcprototype>
				</funcsynopsis>
				
				<para>
					The <varname>$columns</varname> parameter is there for selecting special columns
					that might not be bound to a special table, or some other thing that should be placed in
					the <token>SELECT</token> part of the query.
				</para>
				
				<para>
					(If a column is located in a table which is to be included, use the
					<function linkend="funcref.Db_Query_Select-from">Db_Query_Select->from</function>
					to select the columns, then they will be aliased properly.)
				</para>
			</section>
			
			<section>
				<title>INSERT query builder object</title>
				
				<funcsynopsis xml:id="funcref.Db_Connection-insert">
					<funcprototype>
						<funcdef><type>Db_Query_Insert</type> <function>Db_Connection->insert</function></funcdef>
						
						<paramdef><type>string</type> <parameter>$table</parameter></paramdef>
					</funcprototype>
					
					<funcprototype>
						<funcdef><type>boolean</type> <function>Db_Connection->insert</function></funcdef>
						
						<paramdef><type>string</type> <parameter>$table</parameter></paramdef>
						<paramdef><type>associative array</type> <parameter>$data</parameter></paramdef>
					</funcprototype>
				</funcsynopsis>
				
				<para>
					The <function>Db_Connection->insert</function> method requires a table name which would
					be the name of the table to insert data into. If the <varname>$data</varname> is specified,
					the row will be inserted with the supplied data and a boolean value will be returned
					(<symbol>true</symbol> equals a successful query).
				</para>
			</section>
			
			<section>
				<title>UPDATE query builder object</title>
				
				<funcsynopsis xml:id="funcref.Db_Connection-update">
					<funcprototype>
						<funcdef><type>Db_Query_Update</type> <function>Db_Connection->update</function></funcdef>
						
						<paramdef><type>string</type> <parameter>$table</parameter></paramdef>
						<paramdef choice="opt"><type>associative array</type> <parameter>$data</parameter></paramdef>
					</funcprototype>
					
					<funcprototype>
						<funcdef><type>boolean</type> <function>Db_Connection->update</function></funcdef>
						
						<paramdef><type>string</type> <parameter>$table</parameter></paramdef>
						<paramdef><type>associative array</type> <parameter>$data</parameter></paramdef>
						<paramdef><type>associative array</type> <parameter>$conditions</parameter></paramdef>
					</funcprototype>
				</funcsynopsis>
				
				<para>
					Like the <classname>Db_Connection->insert</classname> this method has two variants:
					one to create a query object and another to create the object, populate it the
					supplied data and finally execute the query and returning the results.
					Both variants uses <varname>$data</varname> to populate the update object, sending
					it to <function linkend="funcref.Db_Query_Update-set">Db_Query_Update->set</function>.
				</para>
				
				<para>
					The <varname>$conditions</varname> array is sent to the
					<function linkend="chapter.query_builders.conditions">Db_Query_Update->where</function> method.
					But if you require some fancy conditions, it might not be satisfactory â€” it would
					be better to use the first variant of <function>Db_Connection->update</function> and
					then apply them using <function>Db_Query->where</function>
					(which <classname>Db_Query_Update</classname> has inherited).
				</para>
			</section>
			
			<section>
				<title>DELETE query builder object</title>
				
				<funcsynopsis xml:id="funcref.Db_Connection-delete">
					<funcprototype>
						<funcdef><type>Db_Query_Delete</type> <function>Db_Connection->delete</function></funcdef>
						
						<paramdef><type>string</type> <parameter>$table</parameter></paramdef>
					</funcprototype>
					
					<funcprototype>
						<funcdef><type>boolean</type> <function>Db_Connection->delete</function></funcdef>
						
						<paramdef><type>string</type> <parameter>$table</parameter></paramdef>
						<paramdef><type>array</type> <parameter>$conditions</parameter></paramdef>
					</funcprototype>
				</funcsynopsis>
				
				<para>
					As you probably already guessed, the first variant is for creating the query object
					and the second is to execute the query directly.
					<varname>$table</varname> is the table name of the table to delete rows from and
					<varname>$conditions</varname> work in the same way as the <varname>$conditions</varname>
					parameter of <function>Db_Connection->update</function>.
				</para>
			</section>
		</section>
		
		<section>
			<title>Getting the generated SQL before it is sent to the database</title>
			
			<para>
				All the Query builders have the <function>Db_Query->getSQL()</function> method,
				making it easy to either debug your queries or to create eg. UNIONs:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-getSQL">
				<funcprototype>
					<funcdef><type>string</type> <function>Db_Query->getSQL</function></funcdef>
					
					<void />
				</funcprototype>
			</funcsynopsis>
			
			<example>
				<title>Creating an UNION query from two Db_Query_Select objects</title>

				<programlisting language="php"><![CDATA[$db = Db::getConnection();

$select1 = $db->select()->from('table1');
$select2 = $db->select()->from('table2');

$query = '('.$select1->getSQL().') UNION ('.$select2->getSQL().')';

$result = $db->query($query);]]></programlisting>
			</example>
		</section>
		
		<section>
			<title>Method chaining</title>
			
			<para>
				All the Query builders can use <firstterm linkend="glossary.method_chaining">method chaining</firstterm>.
				They also return the object instance in almost all cases, except when the method returns the return value
				of the query (or some other "special" method).
			</para>
			
			<example>
				<title>Method Chaining with the Query builders</title>
				
				<programlisting language="php"><![CDATA[$db = Db::getConnection();

// SELECT * FROM `users`:
$result = $db->select()->from('tracks')->get();

foreach($result as $row)
{
	echo $row->name.' - '.$row->artist;
}]]></programlisting>
			</example>
		</section>
	</section>
	
	<section xml:id="chapter.query_builders.select_queries">
		<title>SELECT Queries</title>
		
		<section>
			<title>The FROM part</title>
			
			<para>
				The one call that is required to be made to a <classname>Db_Query_Select</classname> object
				is a call to <function>Db_Query_Select->from</function>, to specify from which table
				to fetch the data.
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Select-from">
				<funcprototype>
					<funcdef><type>Db_Query_Select</type> <function>Db_Query_Select->from</function></funcdef>
					
					<paramdef><type>string</type>|<type>array</type>|<type>Db_Query_Select</type> <parameter>$tables</parameter></paramdef>
					<paramdef choice="opt"><type>string</type>|<type>array</type> <parameter>$columns</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The <varname>$tables</varname> parameter is very versatile, it can be just contain a string
				with the table name â€” making it generate an "anonymous" alias (internally it names them using
				the "<literal>t</literal>" prefix and then a number). Or it can contain an array with several
				table names, aliasing all with different "anonymous" aliases.
			</para>
			
			<example>
				<title>Simple Db_Query_Select->from usage</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select();

$q->from('tracks');

var_dump($q->getSQL());
// SELECT `t1`.* FROM `tracks` AS `t1`

$q2 = Db::getConnection()->select();

$q2->from(array('tracks', 'artists'));

var_dump($q->getSQL());
// SELECT `t1`.*, `t2`.* FROM `tracks` AS `t1`, `artists` AS `t2`]]></programlisting>
			</example>
			
			<para>
				But it can also take an array with non-numeric keys as a parameter.
				This makes it alias the values as the key names:
			</para>
			
			<example>
				<title>Specifying custom aliases using Db_Query_Select->from</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select();

$q->from(array('t' => 'tracks'));

var_dump($q->getSQL());
// SELECT `t`.* FROM `tracks` AS `t`

$q2 = Db::getConnection()->select();

$q2->from(array('t' => 'tracks', 'a' => 'artists'));

var_dump($q->getSQL());
// SELECT `t`.*, `a`.* FROM `tracks` AS `t`, `artists` AS `a`]]></programlisting>
			</example>
			
			<para>
				Finally you can replace the table names with instances of <classname>Db_Query_Select</classname>
				to make them <glossterm>subqueries</glossterm>:
			</para>
			
			<example>
				<title>Using subqueries with Db_Query_Select->from</title>
				
				<programlisting language="php"><![CDATA[// create the subquery
$sq = Db::getConnection()->select();

// here we use the second parameter, going to explain that below â€” but you might figure it out from this :)
$sq->from('tracks', 'artist_id');
$sq->where('play_count >', 20);


$q = Db::getConnection()->select();

$q->from(array('a' => 'artists', 't' => $sq));
$q->where('t.artist_id = a.id');

var_dump($q->getSQL());
// SELECT `a`.*, `t`.*
// FROM `artists` AS `aÂ´,
// (
//     SELECT `t1`.`artist_id` FROM `tracks` AS `t1` WHERE `play_count` > 20
// ) AS `t`
// WHERE `t`.`artist_id` = `a`.`id`]]></programlisting>
			</example>
			
			<para>
				The second parameter of <function>Db_Query_Select->from</function>, <varname>$columns</varname>,
				is used to control which columns to fetch from the database.
				Limiting the number of columns which are fetched from the database increases performance,
				especially when joining other tables which you only filter by (or when using subqueries).
				All the column names are prefixed by the table name, making them unambiguous.
			</para>
			
			<para>
				If the second parameter is an array, all the non-numeric keys are used as aliases
				for the columns (and the alias will be the name to refer to the property which contains
				the column data) â€” the numeric keys will not get any aliases
				(which means that they will get the column name as the property name).
			</para>
			
			<para>
				Essentially, the <varname>$columns</varname> parameter is sent to the
				<function linkend="funcref.Db_Query_Select-columns">Db_Query_Select->columns</function> method.
				See its behaviour for more in-depth information.
			</para>
			
			<example>
				<title>Choosing which columns to fetch with Db_Query_Select->from</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select();

$q->from('tracks', 'name');

var_dump($q->getSQL());
// SELECT `t1`.`name` FROM `tracks` AS `t1`

$q2 = Db::getConnection()->select();

$q->from(array('t' => 'tracks'), array('track' => 'name'));
$q->from(array('a' => 'artists'), array('artist' => 'name'));
$q->where('a.id = t.artist_id');

var_dump($q2->getSQL());
// SELECT `t`.`name` AS `track`, `a`.`name` AS `artist`
// FROM `tracks` AS `t`, `artists` AS `a`
// WHERE `a`.`id` = `t`.`artist_id`]]></programlisting>
			</example>
			
			<para>
				If two tables are specified in the <varname>$tables</varname> array, both will have the
				columns specified in <varname>$columns</varname> SELECTed.
			</para>
			
			<section>
				<title>No escape() combined with Db_Query_Select->from</title>
				
				<para>
					If <function linkend="funcref.Db_Query-escape">Db_Query->escape</function> is set to
					<symbol>false</symbol>, then the <varname>$columns</varname> parameter won't be escaped,
					just like the <function linkend="funcref.Db_Query_Select-column">Db_Query_Select->column</function>
					works when escaping is turned off.
				</para>
			</section>
		</section>
		
		<section>
			<title>Selecting additional columns</title>
			
			<para>
				To select extra columns, which might not be bound to a specific table or columns that
				needs to be added later in the execution (to a table which already have been used in
				<function linkend="funcref.Db_Query_Select-from">Db_Query_Select->from</function>),
				you use <function>Db_Query_Select->column</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Select-column">
				<funcprototype>
					<funcdef><type>Db_Query_Select</type> <function>Db_Query_Select->column</function></funcdef>
					
					<paramdef><type>string</type>|<type>array</type>|<type>Db_Query_Select</type> <parameter>$columns</parameter></paramdef>
					<paramdef choice="opt"><type>string</type> <parameter>$table</parameter> = <symbol>false</symbol></paramdef>
					<paramdef choice="opt"><type>bool</type> <parameter>$table_is_aliased</parameter> = <symbol>false</symbol></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				TODO: MORE
			</para>
		</section>
	</section>
	
	<section xml:id="chapter.query_builders.insert_queries">
		<title>INSERT Queries</title>
		
		<para>
			TODO: MORE
		</para>
	</section>
	
	<section xml:id="chapter.query_builders.update_queries">
		<title>UPDATE Queries</title>
		
		<para>
			TODO: MORE
		</para>
	</section>
	
	<section xml:id="chapter.query_builders.delete_queries">
		<title>DELETE Queries</title>
		
		<para>
			TODO: MORE
		</para>
	</section>
	
	<section xml:id="chapter.query_builders.escaping">
		<title>Controlling escaping</title>
		
		<para>
			By default are all the data sent into the query builders either
			<glossterm linkend="glossary.escaping">escaped</glossterm>
			or <glossterm linkend="glossary.identifier_protection">identifier protected</glossterm>.
			To control escaping <classname>Db_Query</classname> and all its descendants has the
			<function>Db_Query->escape</function>:
		</para>
		
		<funcsynopsis xml:id="funcref.Db_Query-escape">
			<funcprototype>
				<funcdef><type>Db_Query</type> <function>Db_Query->escape</function></funcdef>
				
				<paramdef choice="opt"><type>bool</type> <parameter>$escape</parameter> = <symbol>true</symbol></paramdef>
			</funcprototype>
		</funcsynopsis>
		
		<para>
			<function>Db_Query->escape</function> will return the object it is located on, which means
			that if it is called on a <classname>Db_Query_Select</classname> object, that object instance
			will be returned.
		</para>
		
		<para>
			The setting that <function>Db_Query->escape</function> controls does not affect previous calls
			to the query object, so if you want to disable escaping for some parts and not for others,
			it is definitely possible.
		</para>
		
		<example>
			<title>Switching escaping on and off during construction of a single query</title>
			
			<programlisting language="php"><![CDATA[$q = Db::getConnection()->select();

$q->from('artists', 'name');

$q->escape(false);
$q->column('COUNT(tracks.id)');

$q->escape(true);
$q->join('tracks', 'tracks.artist_id = artists.id', array()); // no need to select columns
$q->groupBy('artists.name');

var_dump($q->getSQL());
// SELECT `t1`.`name`, COUNT(artists.id)
// FROM `artists` AS `t1`
// JOIN `tracks` AS `t2` ON `tracks`.`artist_id` = `artists`.`id`
// GROUP BY `artists`.`name`]]></programlisting>
		</example>
		
		<para>
			TODO: MORE?
		</para>
	</section>
	
	<section xml:id="chapter.query_builders.conditions">
		<title>The Different SQL Conditions</title>
		
		<para>
			Conditions are very common in SQL, and it is almost impossible to avoid them.
			As soon as you need to filter something you have to use them
			(unless you want to do it the slow way: load everything and then iterate in PHP).
		</para>
		
		<para>
			RapidDataMapper provides helper methods on the query objects to make it easy
			to both create the initial conditions but also to simplify the addition of
			extra conditions.
			The conditions do not have to be specified all at once, instead you can add
			them wherever the need arises.
		</para>
		
		<para>
			The code below dynamically adds a <token>LIKE</token> condition to a query when
			it is a "search request":
		</para>
		
		<example>
			<title>Adding additional WHERE conditions</title>
			
			<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

$q->where('artist', $_POST['name']);

if($search)
{
	$q->like('name', $_POST['search']);
}

$result = $q->get();]]></programlisting>
		</example>
		
		<section xml:id="chapter.query_builders.conditions.or">
			<title>Replacing AND with OR boolean operators</title>
			
			<para>
				All the conditions have their methods on the query building objects (except for INSERT which
				does not have the need) and the first parameter behaves the same on all of them:
				It is <glossterm>identifier protected</glossterm> and if it is prefixed by an OR ("<literal>or </literal>")
				then an <token>OR</token> operator will precede the condition instead of an <token>AND</token>.
			</para>

			<para>
				If there are no earlier conditions no boolean operator will be prepended, even if you
				explicitly write "<literal>or </literal>" before the column name.
			</para>

			<example>
				<title>Using OR operators</title>

				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

// this is very foolish, use Db_Query->whereIn() instead as it will be both faster on the PHP and database ends
foreach($_POST['artists'] as $artist)
{
	$q->where('or artist', $artist);
}]]></programlisting>
			</example>
		</section>
		
		<section xml:id="chapter.query_builders.conditions.where">
			<title>WHERE</title>
			
			<para>
				The <token>WHERE</token> condition is the most commonly used and also the one with
				the most features in the query builder. It can add the conditions in sequences,
				but it can also nest them in parenthesis and use <glossterm>subqueries</glossterm>.
			</para>
			
			<para>
				By default all the conditions and values sent to <function>Db_Query->where</function>
				will be identifier protected and escaped, respectively.
				The identifier protection will protect all the identifiers (to avoid both injection attacks
				and interference with database keywords) but it will preserve all conditional operators
				(eg. "<literal>=</literal>", "<literal>&lt;</literal>", "<literal>&gt;</literal>",
				"<literal>!=</literal>").
			</para>
			
			<para>
				To avoid escaping or identifier protection, use
				<link linkend="funcref.Db_Query-escape"><function>Db_Query->escape</function></link>
				to temporarily switch escaping off.
			</para>
			
			<para>
				Function synopsis for <function>Db_Query->where</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-where">
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->where</function></funcdef>
					
					<paramdef choice="opt"><type>string</type> <parameter>$condition</parameter> = 'or'</paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->where</function></funcdef>
					
					<paramdef><type>array</type> <parameter>$condition</parameter></paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->where</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$condition</parameter></paramdef>
					<paramdef choice="opt"><type>scalar</type> <parameter>$value</parameter></paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->where</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$condition</parameter></paramdef>
					<paramdef><type>Db_Query_Select</type> <parameter>$subquery</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<section>
				<title>Nesting WHERE conditions</title>
				
				<para>
					The first variant creates a nested list of conditions that will be wrapped in parenthesis.
					If the first parameter is empty, it will be preceded by <token>AND</token> if there are
					conditions before it. If the first parameter is equal to "<literal>or</literal>" it will
					instead be preceded by <token>OR</token>.
				</para>
				
				<para>
					You can not only use <function>Db_Query->where</function> in the nested query
					(on the nested where object), but also
					<function linkend="funcref.Db_Query-whereIn">Db_Query->whereIn</function>,
					<function linkend="funcref.Db_Query-whereNotIn">Db_Query->whereNotIn</function> and
					<function linkend="funcref.Db_Query-like">Db_Query->like</function>.
				</para>
				
				<example>
					<title>Using nested WHERE conditions</title>
					
					<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

// store the nested variant in $nested
$nested = $q->where();

// no need to reassign it to $q again, it is already linked with the proper place in the WHERE stack in $q
$nested->where('artist', 'Within Temptation');
$nested->where('or artist', 'Skyfire');

// add another condition after the nested conditions
$q->like('name', 'intro');

$r = $q->get();
// SELECT t1.* FROM tracks WHERE (`artist` = 'Within Temptation' OR `artist` = 'Skyfire') AND `name` LIKE '%intro%']]></programlisting>
				</example>
			</section>
			
			<section>
				<title>Conditions between two columns</title>
				
				<para>
					The second variant is a lot simpler, it will simply append the <varname>$condition</varname>
					to the WHERE stack (but it will still parse the OR condition if present, and also
					protect the identifiers provided escaping is on):
				</para>
				
				<example>
					<title>Adding conditions between different columns</title>
					
					<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

$q->where('name = artist'); // WHERE `name` = `artist`

$r = $q->get();]]></programlisting>
				</example>
			</section>
			
			<section>
				<title>Conditions between column and a value</title>
				
				<para>
					To add a condition which compares a column with a specified value, you just supply a
					column name as the first parameter (<varname>$condition</varname>, with optional
					comparison operator) and the value to compare with as the <varname>$value</varname> parameter.
				</para>
				
				<para>
					If the <varname>$condition</varname> does not have a condition at the end, an equal
					sign ("<literal>=</literal>") will be appended. The check for a boolean <token>OR</token>
					operator will also be made (see
					<link linkend="chapter.query_builders.conditions.or">Replacing AND with OR boolean operators</link>).
				</para>
				
				<para>
					If <function linkend="funcref.Db_Query-escape">Db_Query->escape</function> is set to <symbol>false</symbol>,
					<varname>$condition</varname> will not be identifier protected (conditions will still be
					appended and <token>OR</token> will also be parsed, and if a condition is missing at the
					end of <varname>$condition</varname>, an "<literal>=</literal>" will still be appended)
					and <varname>$value</varname> will be concatenated (no escaping) and then appended to the WHERE
					stack.
				</para>
				
				<example>
					<title>Comparing column to a value</title>
					
					<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

$q->where('artist', 'Wintersun'); // `artist` = 'Wintersun'
$q->where('or artist =', 'Within Temptation'); // OR `artist` = 'Within Temptation'
$q->where('plays >', 23); // AND `plays` > 23

// no escaping:
$q->escape(false);
$q->where('or LOWER(name)', 'something \' not escaped');
// OR LOWER(name) = something ' not escaped
// recommending this instead:
$q->where('or LOWER(name)', Db::getConnection()->escape('something \' escaped'));
// OR LOWER(name) = 'something \' escaped'

// switching escaping to on (not strictly needed in this case,
// but good to do if you eg. want to insert more code after the unescaped condition):
$q->escape(true);

$r = $q->get();]]></programlisting>
				</example>
			</section>
			
			<section>
				<title>Condition with a subquery</title>
				
				<para>
					You can also make a condition that compares a column to a single value returned
					by a subquery (notice: SINGLE value, otherwise it is a high probability that the
					database will complain).
				</para>
				
				<para>
					It will work the same as if you compare a column with a value, only that the value
					is substituted with the subquery.
				</para>
				
				<example>
					<title>Comparing a column with a subquery</title>
					
					<programlisting language="php"><![CDATA[$db = Db::getConnection();

$q   = $db->select()->from('tracks');
$sub = $db->select()->from('tracks', 'name')->where('plays >', 23)->limit(1);

$q->where('artist', $sub); // `artist` = (SELECT `name` FROM `tracks` WHERE `plays` > 23 LIMIT 1)

$r = $q->get();]]></programlisting>
				</example>
			</section>
		</section>
		
		<section xml:id="chapter.query_builders.conditions.where_in">
			<title>WHERE IN</title>
			
			<para>
				The WHERE IN condition matches a single column against a list of values, matching if
				the column matches at least one of the values.
				The WHERE IN condition is added to a query by calling <function>Db_Query->whereIn</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-whereIn">
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->whereIn</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef><type>array</type> <parameter>$values</parameter></paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->whereIn</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef><type>Db_Query_Select</type> <parameter>$values</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				As usual you can prepend an <token>or</token> to the column to concatenate it
				with an OR to the previous condition.
			</para>
			
			<example>
				<title>Using WHERE IN with a PHP array</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

$titles = array('Ten Leagues Beneath Contempt', 'Genesis', 'Loot Burn Rape Kill Repeat');

$q->whereIn('name', $titles); // WHERE `name` IN ('Ten Leagues Beneath Contempt', 'Genesis', 'Loot Burn Rape Kill Repeat')

$r = $q->get();]]></programlisting>
			</example>
			
			<example>
				<title>Using subqueries with WHERE IN</title>
				
				<programlisting language="php"><![CDATA[$db = Db::getConnection();

$q  = $db->select()->from('artists');

$q2 = $db->select()->from('tracks', 'name'); // important to only select one column
$q2->escape(false)->having('COUNT(name) >', 2)->groupBy('name');

$q->whereIn('name', $q2); // WHERE `name` IN (SELECT `name` FROM `tracks` HAVING COUNT(name) > 2 GROUP BY `name`)

$r = $q->get();]]></programlisting>
			</example>
			
			<para>
				If the <function linkend="funcref.Db_Query-escape">Db_Query->escape</function> method
				has set escaping to <symbol>false</symbol>, <varname>$column</varname> will not be identifier
				protected (but "<literal>OR </literal>" is still parsed).
			</para>
			
			<example>
				<title>Using WHERE IN without escaping the column</title>
				
				<programlisting language="php"><![CDATA[$q = Db:getConnection()->select()->from('tracks');

$q->escape(false);
$q->where('LOWER(name)', $titles);
// WHERE LOWER(name) IN (some list goes here)

$r = $q->get();]]></programlisting>
			</example>
		</section>
		
		<section xml:id="chapter.query_builders.conditions.where_not_in">
			<title>WHERE NOT IN</title>
			
			<para>
				This is a variant of the WHERE IN condition, but instead of searching for matches
				to the supplied list it searches for columns NOT matching the list.
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-whereNotIn">
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->whereNotIn</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef><type>array</type> <parameter>$values</parameter></paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->whereNotIn</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef><type>Db_Query_Select</type> <parameter>$values</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		</section>
		
		<section xml:id="chapter.query_builders.conditions.like">
			<title>LIKE</title>
			
			<para>
				To add a LIKE search condition, use <function>Db_Query->like</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-like">
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->like</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef><type>array</type> <parameter>$match</parameter></paramdef>
					<paramdef choice="opt"><type>string</type> <parameter>$side</parameter> = "<literal>both</literal>"</paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The <varname>$column</varname> parameter is filtered for "<literal>or </literal>" and also identifier
				protected.
				<varname>$match</varname> is escaped, with the addition that LIKE wildcards also are escaped
				(eg. in MySQL are "<literal>%</literal>" and "<literal>_</literal>" escaped), to prevent
				a too high workload on the server.
			</para>
			
			<para>
				The <varname>$side</varname> parameter dictates on which side the "<literal>%</literal>"
				wildcards should be placed ("<literal>%</literal>" matches any number of characters of any type).
				The possible values are "<literal>left</literal>", "<literal>right</literal>"
				and "<literal>both</literal>".
			</para>
			
			<example>
				<title>Using Db_Query->like</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

$q->like('name', 'loss', 'left'); // WHERE `name` LIKE '%loss'

$q->escape(false);
$q->like('or LOWER(artist)', 'dark'); // OR LOWER(artist) LIKE '%dark%'

$r = $q->get();]]></programlisting>
			</example>
		</section>
		
		<section xml:id="chapter.query_builders.conditions.bind_where">
			<title>Fragments with parameters added to WHERE</title>
			
			<para>
				Sometimes you would like to add a large prewritten condition (or list of conditions) to the WHERE part
				of the query, but still be able to escape all the values.
				RapidDataMapper provides a way for you to do that, where it only replaces certain placeholders
				with the escaped values.
				This is also called prepared statements with bound parameters.
			</para>
			
			<para>
				(Actually, it is not, but it works exactly like it on the PHP side.)
			</para>
			
			<para>
				This works like the <varname>$binds</varname> parameter to
				<function linkend="funcref.Db_Connection-query">Db_Connection->query</function>,
				with the exception that it only appends it to the WHERE part of the query.
				It also parses any prepended "<literal>or </literal>" on the <varname>$condition</varname>
				parameter.
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-bindWhere">
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->bindWhere</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$condition</parameter></paramdef>
					<paramdef><type>array</type> <parameter>$binds</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<example>
				<title>Using bound parameters in the WHERE part of a query builder</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnnection()->select()->from('tracks');

// requires two parameters, first = name, second = artist
$q->bindWhere('LOWER(name) = ? OR SUBSTR(name, 3) = SUBSTR(artist, -3) AND artist = ?', $_POST);

$r = $q->get();]]></programlisting>
			</example>
		</section>
	</section>
</chapter>