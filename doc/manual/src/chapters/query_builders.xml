<?xml version="1.0" encoding="utf-8"?>
<chapter
	version="5.0"
	xml:id="chapter.query_builders"
	xml:lang="en"
	xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:db="http://docbook.org/ns/docbook"
	>
	
	<title>Query Builders</title>
	
	<section>
		<title>Query builders at a glance</title>
		
		<para>
			The query builders are a set of PHP classes which generate <acronym>SQL</acronym>.
			These classes contain methods which manipulate the final output,
			making it possible to easily tailor a query dynamically without
			fear of malformed <acronym>SQL</acronym> or compromised security. 
		</para>
		
		<para>
			The classes, starting with <classname>Db_Query_*</classname> are responsible
			for one type of query each: SELECT (
			<classname linkend="chapter.query_builders.select_queries">Db_Query_Select</classname>),
			INSERT (<classname linkend="chapter.query_builders.insert_queries">Db_Query_Insert</classname>),
			UPDATE (<classname linkend="chapter.query_builders.update_queries">Db_Query_Update</classname>) and
			DELETE (<classname linkend="chapter.query_builders.delete_queries">Db_Query_Delete</classname>)
		</para>
		
		<para>
			The benefits of using query builders are several:
		</para>
		
		<itemizedlist>
			<listitem>
				<para>
					Automatic escaping and protection from <acronym>SQL</acronym> injection attacks and other SQL-vulnerabilities.
				</para>
			</listitem>
			
			<listitem>
				<para>
					You can easily manipulate queries before executing them,
					no need to perform complex string building or to call escaping methods all the time.
				</para>
			</listitem>
			
			<listitem>
				<para>
					Almost no risk of executing malformed SQL.
				</para>
			</listitem>
		</itemizedlist>
		
		<para>
			A few drawbacks:
		</para>
		
		<itemizedlist>
			<listitem>
				<para>
					A small loss of performance when generating the queries.
				</para>
			</listitem>
			
			<listitem>
				<para>
					The query builders cannot create all types of <acronym>SQL</acronym>.
				</para>
			</listitem>
		</itemizedlist>
	</section>
	
	<section>
		<title>Generic Usage</title>
		
		<para>
			The different query builders work very alike, they differ in a few key points
			in the same way that the different query types differ between each other.
		</para>
		
		<section>
			<title>Getting a query builder object</title>
			
			<para>
				To get a query builder object, you call a specific method on the
				<classname linkend="chapter.database_connection_objects">Db_Connection</classname> object(s):
			</para>
			
			<section>
				<title>SELECT query builder object</title>
				
				<funcsynopsis xml:id="funcref.Db_Connection-select">
					<funcprototype>
						<funcdef><type>Db_Query_Select</type> <function>Db_Connection->select</function></funcdef>
						
						<paramdef choice="opt"><type>mixed</type> <parameter>$columns</parameter></paramdef>
					</funcprototype>
				</funcsynopsis>
				
				<para>
					The <parameter>$columns</parameter> parameter is there for selecting special columns
					that might not be bound to a special table, or some other thing that should be placed in
					the <token>SELECT</token> part of the query.
				</para>
				
				<para>
					(If a column is located in a table which is to be included, use the
					<function linkend="funcref.Db_Query_Select-from">Db_Query_Select->from</function>
					to select the columns, then they will be aliased properly.)
				</para>
			</section>
			
			<section>
				<title>INSERT query builder object</title>
				
				<funcsynopsis xml:id="funcref.Db_Connection-insert">
					<funcprototype>
						<funcdef><type>Db_Query_Insert</type> <function>Db_Connection->insert</function></funcdef>
						
						<paramdef><type>string</type> <parameter>$table</parameter></paramdef>
					</funcprototype>
					
					<funcprototype>
						<funcdef><type>boolean</type> <function>Db_Connection->insert</function></funcdef>
						
						<paramdef><type>string</type> <parameter>$table</parameter></paramdef>
						<paramdef><type>associative array</type> <parameter>$data</parameter></paramdef>
					</funcprototype>
				</funcsynopsis>
				
				<para>
					The <function>Db_Connection->insert</function> method requires a table name which would
					be the name of the table to insert data into. If the <parameter>$data</parameter> is specified,
					the row will be inserted with the supplied data and a boolean value will be returned
					(<symbol>true</symbol> equals a successful query).
				</para>
			</section>
			
			<section>
				<title>UPDATE query builder object</title>
				
				<funcsynopsis xml:id="funcref.Db_Connection-update">
					<funcprototype>
						<funcdef><type>Db_Query_Update</type> <function>Db_Connection->update</function></funcdef>
						
						<paramdef><type>string</type>|<type>array</type> <parameter>$table</parameter></paramdef>
						<paramdef choice="opt"><type>associative array</type> <parameter>$data</parameter></paramdef>
					</funcprototype>
					
					<funcprototype>
						<funcdef><type>boolean</type> <function>Db_Connection->update</function></funcdef>
						
						<paramdef><type>string</type> <parameter>$table</parameter></paramdef>
						<paramdef><type>associative array</type> <parameter>$data</parameter></paramdef>
						<paramdef><type>associative array</type> <parameter>$conditions</parameter></paramdef>
					</funcprototype>
				</funcsynopsis>
				
				<para>
					Like the <function>Db_Connection->insert</function> this method has two variants:
					one to create a query object and another to create the object, populate it the
					supplied data and finally execute the query and returning the results.
					Both variants uses <parameter>$data</parameter> to populate the update object, sending
					it to <function linkend="funcref.Db_Query_Update-set">Db_Query_Update->set</function>.
				</para>
				
				<para>
					The <parameter>$conditions</parameter> array is sent to the
					<function linkend="chapter.query_builders.conditions">Db_Query_Update->where</function> method.
					But if you require some fancy conditions, it might not be satisfactory â€” it would
					be better to use the first variant of <function>Db_Connection->update</function> and
					then apply them using
					<function linkend="chapter.query_builders.conditions">Db_Query->where</function>
					(which <classname>Db_Query_Update</classname> has inherited).
				</para>
			</section>
			
			<section>
				<title>DELETE query builder object</title>
				
				<funcsynopsis xml:id="funcref.Db_Connection-delete">
					<funcprototype>
						<funcdef><type>Db_Query_Delete</type> <function>Db_Connection->delete</function></funcdef>
						
						<paramdef><type>string</type>|<type>array</type> <parameter>$table</parameter></paramdef>
					</funcprototype>
					
					<funcprototype>
						<funcdef><type>boolean</type> <function>Db_Connection->delete</function></funcdef>
						
						<paramdef><type>string</type>|<type>array</type> <parameter>$table</parameter></paramdef>
						<paramdef><type>array</type> <parameter>$conditions</parameter></paramdef>
					</funcprototype>
				</funcsynopsis>
				
				<para>
					As you probably already guessed, the first variant is for creating the query object
					and the second is to execute the query directly.
					<parameter>$table</parameter> is the table name of the table to delete rows from and
					<parameter>$conditions</parameter> work in the same way as the <parameter>$conditions</parameter>
					parameter of <function>Db_Connection->update</function>.
				</para>
				
				<para>
					<parameter>$table</parameter> can also be an array, if you want to do a multi-table
					delete.
					If the keys are non-numeric, they will be used as aliases for the table name which
					is stored in the value.
				</para>
				
				<warning>
					<para>
						If you specify multiple tables, make sure that the <parameter>$conditions</parameter>
						parameter reference the correct table if several tables has the same column names.
					</para>
				</warning>
			</section>
		</section>
		
		<section>
			<title>Getting the generated SQL before it is sent to the database</title>
			
			<para>
				All the Query builders have the <function>Db_Query->getSQL()</function> method,
				making it easy to either debug your queries or to create eg. UNIONs:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-getSQL">
				<funcprototype>
					<funcdef><type>string</type> <function>Db_Query->getSQL</function></funcdef>
					
					<void />
				</funcprototype>
			</funcsynopsis>
			
			<example>
				<title>Creating an UNION query from two Db_Query_Select objects</title>

				<programlisting language="php"><![CDATA[$db = Db::getConnection();

$select1 = $db->select()->from('table1');
$select2 = $db->select()->from('table2');

$query = '('.$select1->getSQL().') UNION ('.$select2->getSQL().')';

$result = $db->query($query);]]></programlisting>
			</example>
		</section>
		
		<section>
			<title>Method chaining</title>
			
			<para>
				All the Query builders can use <firstterm linkend="glossary.method_chaining">method chaining</firstterm>.
				They also return the object instance in almost all cases, except when the method returns the return value
				of the query (or some other "special" method).
			</para>
			
			<example>
				<title>Method Chaining with the Query builders</title>
				
				<programlisting language="php"><![CDATA[$db = Db::getConnection();

// SELECT * FROM `users`:
$result = $db->select()->from('tracks')->get();

foreach($result as $row)
{
	echo $row->name.' - '.$row->artist;
}]]></programlisting>
			</example>
		</section>
	</section>
	
	<section xml:id="chapter.query_builders.select_queries">
		<title>SELECT Queries</title>
		
		<section>
			<title>The FROM part</title>
			
			<para>
				The one call that is required to be made to a <classname>Db_Query_Select</classname> object
				is a call to <function>Db_Query_Select->from</function>, to specify from which table
				to fetch the data.
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Select-from">
				<funcprototype>
					<funcdef><type>Db_Query_Select</type> <function>Db_Query_Select->from</function></funcdef>
					
					<paramdef><type>string</type>|<type>array</type>|<type>Db_Query_Select</type> <parameter>$tables</parameter></paramdef>
					<paramdef choice="opt"><type>string</type>|<type>array</type> <parameter>$columns</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The <parameter>$tables</parameter> parameter is very versatile, it can be just contain a string
				with the table name â€” making it generate an "anonymous" alias (internally it names them using
				the "<literal>t</literal>" prefix and then a number).
				Or it can contain an array with several table names, aliasing all with different "anonymous" aliases.
			</para>
			
			<example>
				<title>Simple Db_Query_Select->from usage</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select();

$q->from('tracks');

var_dump($q->getSQL());
// SELECT `t1`.* FROM `tracks` AS `t1`

$q2 = Db::getConnection()->select();

$q2->from(array('tracks', 'artists'));

var_dump($q->getSQL());
// SELECT `t1`.*, `t2`.* FROM `tracks` AS `t1`, `artists` AS `t2`]]></programlisting>
			</example>
			
			<para>
				But it can also take an array with non-numeric keys as a parameter.
				This makes it alias the values as the key names:
			</para>
			
			<example>
				<title>Specifying custom aliases using Db_Query_Select->from</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select();

$q->from(array('t' => 'tracks'));

var_dump($q->getSQL());
// SELECT `t`.* FROM `tracks` AS `t`

$q2 = Db::getConnection()->select();

$q2->from(array('t' => 'tracks', 'a' => 'artists'));

var_dump($q->getSQL());
// SELECT `t`.*, `a`.* FROM `tracks` AS `t`, `artists` AS `a`]]></programlisting>
			</example>
			
			<para>
				Finally you can replace the table names with instances of <classname>Db_Query_Select</classname>
				to make them <glossterm>subqueries</glossterm>:
			</para>
			
			<example>
				<title>Using subqueries with Db_Query_Select->from</title>
				
				<programlisting language="php"><![CDATA[// create the subquery
$sq = Db::getConnection()->select();

// here we use the second parameter, going to explain that below â€” but you might figure it out from this :)
$sq->from('tracks', 'artist_id');
$sq->where('play_count >', 20);


$q = Db::getConnection()->select();

$q->from(array('a' => 'artists', 't' => $sq));
$q->where('t.artist_id = a.id');

var_dump($q->getSQL());
// SELECT `a`.*, `t`.*
// FROM `artists` AS `aÂ´,
// (
//     SELECT `t1`.`artist_id` FROM `tracks` AS `t1` WHERE `play_count` > 20
// ) AS `t`
// WHERE `t`.`artist_id` = `a`.`id`]]></programlisting>
			</example>
			
			<para>
				The second parameter of <function>Db_Query_Select->from</function>, <parameter>$columns</parameter>,
				is used to control which columns to fetch from the database.
				Limiting the number of columns which are fetched from the database increases performance,
				especially when joining other tables which you only filter by (or when using subqueries).
				All the column names are prefixed by the table name, making them unambiguous.
			</para>
			
			<para>
				If the second parameter is an array, all the non-numeric keys are used as aliases
				for the columns (and the alias will be the name to refer to the property which contains
				the column data) â€” the numeric keys will not get any aliases
				(which means that they will get the column name as the property name).
			</para>
			
			<para>
				Essentially, the <parameter>$columns</parameter> parameter is sent to the
				<function linkend="funcref.Db_Query_Select-column">Db_Query_Select->columns</function> method.
				See its behaviour for more in-depth information.
			</para>
			
			<example>
				<title>Choosing which columns to fetch with Db_Query_Select->from</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select();

$q->from('tracks', 'name');

var_dump($q->getSQL());
// SELECT `t1`.`name` FROM `tracks` AS `t1`

$q2 = Db::getConnection()->select();

$q->from(array('t' => 'tracks'), array('track' => 'name'));
$q->from(array('a' => 'artists'), array('artist' => 'name'));
$q->where('a.id = t.artist_id');

var_dump($q2->getSQL());
// SELECT `t`.`name` AS `track`, `a`.`name` AS `artist`
// FROM `tracks` AS `t`, `artists` AS `a`
// WHERE `a`.`id` = `t`.`artist_id`]]></programlisting>
			</example>
			
			<para>
				If two tables are specified in the <parameter>$tables</parameter> array, both will have the
				columns specified in <parameter>$columns</parameter> SELECTed.
			</para>
			
			<section>
				<title>No escape() combined with Db_Query_Select->from</title>
				
				<para>
					If <function linkend="funcref.Db_Query-escape">Db_Query->escape</function> is set to
					<symbol>false</symbol>, then the <parameter>$columns</parameter> parameter won't be escaped,
					just like the <function linkend="funcref.Db_Query_Select-column">Db_Query_Select->column</function>
					works when escaping is turned off.
				</para>
			</section>
		</section>
		
		<section>
			<title>Selecting additional columns</title>
			
			<para>
				To select extra columns, which might not be bound to a specific table or columns that
				needs to be added later in the execution (to a table which already have been used in
				<function linkend="funcref.Db_Query_Select-from">Db_Query_Select->from</function>),
				you use <function>Db_Query_Select->column</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Select-column">
				<funcprototype>
					<funcdef><type>Db_Query_Select</type> <function>Db_Query_Select->column</function></funcdef>
					
					<paramdef><type>string</type>|<type>array</type>|<type>Db_Query_Select</type> <parameter>$columns</parameter></paramdef>
					<paramdef choice="opt"><type>string</type> <parameter>$table</parameter> = <initializer>false</initializer></paramdef>
					<paramdef choice="opt"><type>bool</type> <parameter>$table_is_aliased</parameter> = <initializer>false</initializer></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The first parameter <parameter>$columns</parameter> contains columns
				which will be appended to the SELECT part of the query.
				If <parameter>$columns</parameter> is a string, it will just be <glossterm>identifier protected</glossterm>
				and then appended.
				And if it is an array, the non-numeric keys will be used as aliases for the columns.
			</para>
			
			<para>
				The <parameter>$table</parameter> parameter is the name of the table from which the columns
				should be selected.
				This is used to prevent unambiguous column names inside the SELECT.
				If it is non-empty, this table name will be prepended to all the specified columns
				(with a dot in between).
				The <parameter>$table</parameter> will also be <glossterm>identifier protected</glossterm>.
			</para>
			
			<para>
				<parameter>$table_is_aliased</parameter> controls whether the
				<link linkend="database_connection_objects.database_prefix">Database Prefix</link>
				will be prepended to <parameter>$table</parameter> before it is added to the query.
				This is used when you refer to columns from eg. an alias.
			</para>
			
			<section>
				<title>No escape() and column()</title>
				
				<para>
					If <function linkend="funcref.Db_Query-escape">escape</function> is set to <symbol>false</symbol>
					the columns won't be <glossterm>identifier protected</glossterm>.
					The aliases will still be <glossterm>identifier protected</glossterm> even if the columns
					themselves are not.
				</para>
				
				<example>
					<title>Counting the number of rows in a table</title>
					
					<programlisting language="php"><![CDATA[$q = Db::getConnection()->select();

$q->from('tracks', array()); // do not select any columns from tracks
$q->escape(false);
$q->column('COUNT(1)');

$number_of_tracks = $q->get()->val();]]></programlisting>
				</example>
			</section>
		</section>
		
		<section>
			<title>Joining tables (JOIN)</title>
			
			<para>
				To join another table to the tables you already have specified with
				<function linkend="funcref.Db_Query_Select-from">Db_Query_Select->from</function>,
				use <function>Db_Query_Select->join</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Select-join">
				<funcprototype>
					<funcdef><type>Db_Query_Select</type> <function>Db_Query_Select->join</function></funcdef>
					
					<paramdef><type>string</type>|<type>array</type>|<type>Db_Query_Select</type> <parameter>$table</parameter></paramdef>
					<paramdef><type>string</type> <parameter>$condition</parameter></paramdef>
					<paramdef choice="opt"><type>array</type> <parameter>$columns</parameter> = <initializer>false</initializer></paramdef>
					<paramdef choice="opt"><type>string</type> <parameter>$type</parameter> = "<initializer>left</initializer>"</paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The first parameter is the table name to join, which can be without alias,
				with alias (in an array where the alias is key, only the first key=>value pair will be joined)
				and a subquery (just replace the string with the variable containing the subquery).
			</para>
			
			<para>
				The second parameter, <parameter>$condition</parameter>, is as it sounds,
				a list of conditions to fulfill for the JOIN.
				They are in the same syntax as the single parameter variant of
				<function linkend="funcref.Db_Query-where">Db_Query->where</function>
				(both the string and array variants),
				which means that it will be identifier protected if it is a plain string
				(provided <function linkend="funcref.Db_Query-escape">Db_Query->escape</function>
				is set to <symbol>true</symbol>).
			</para>
			
			<para>
				The third parameter is the names of the columns to select.
				By default <function>Db_Query_Select->join</function> selects all columns
				(<parameter>$columns</parameter> = <symbol>false</symbol>),
				but by sending other values it is possible to select some or none
				(use an empty array for no columns).
				<parameter>$columns</parameter> will be sent to
				<function linkend="funcref.Db_Query_Select-column">Db_Query_Select->column</function>
				(as the first parameter),
				which means that they can also be aliased or controlled by escaping.
			</para>
			
			<para>
				And lastly we have the <parameter>$type</parameter> parameter which will determine what
				type of JOIN will be performed.
				This string will be uppercased and put before "<literal>JOIN</literal>" in the query
				(NOTE: It won't be validated, so do not use data from the user without strict validation).
			</para>
			
			<example>
				<title>Joining tables</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select();

$q->from('tracks');
$q->join('artists', 'artist.id = tracks.artist_id');

$r = $q->get();
// SELECT `t1`.*, `t2`.*
// FROM `tracks` AS `t1`
// LEFT JOIN `artists` AS `t2` ON `artistÂ´.`id` = `tracks`.`artist_id`

$q2 = Db::getConnection()->select();

$q2->from('tracks', array('track_name' => 'name'));
$q2->join('artists', 'artists.id = tracks.id', array('artist_name' => 'name'), 'inner');

$r2 = $q2->get();
// SELECT `t1`.`name` AS `track_name`, `t2`.`name` AS `artist_name`
// FROM `tracks` AS `t1`
// INNER JOIN `artists` AS `t2` ON `artistÂ´.`id` = `tracks`.`artist_id`]]></programlisting>
			</example>
			
			<section>
				<title>No escape() and join()</title>
				
				<para>
					The parameters affected by <function linkend="funcref.Db_Query-escape">Db_Query->escape</function>
					are <parameter>$condition</parameter> and <parameter>$columns</parameter>.
					<parameter>$columns</parameter> will behave just like the first parameter of
					<function linkend="funcref.Db_Query_Select-column">Db_Query_Select->column</function>
					and <parameter>$condition</parameter> behaves just like the first parameter of
					<function linkend="funcref.Db_Query-where">Db_Query->where</function>.
				</para>
			</section>
		</section>
		
		<section>
			<title>Filtering columns aggregated by GROUP BY (ie. using HAVING)</title>
			
			<para>
				To add a having clause to the query, use <function>Db_Query_Select->having</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Select-having">
				<funcprototype>
					<funcdef><type>Db_Query_Select</type> <function>Db_Query_Select->having</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$condition</parameter></paramdef>
					<paramdef choice="opt"><type>scalar</type> <parameter>$value</parameter> = <initializer>NULL</initializer></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The first parameter is never identifier protected, nor is it escaped.
				This is because the filter used in HAVING is often an aggregate function,
				such as <literal>SUM</literal> or <literal>MAX</literal>.
				<parameter>$condition</parameter> will also be filtered for "<literal>or</literal>"
				in the beginning of the string (just like the
				<function linkend="chapter.query_builders.conditions.or">OR filtering of Db_Query->where</function>).
			</para>
			
			<para>
				If <parameter>$value</parameter> is <symbol>null</symbol>, then the <parameter>$condition</parameter> will
				be appended to the HAVING clause.
				But if this parameter is not <symbol>null</symbol> it will be escaped
				(provided <function linkend="funcref.Db_Query-escape">Db_Query->escape</function> is
				<symbol>true</symbol>, default) and concatenated with <parameter>$condition</parameter>
				(if the <parameter>$condition</parameter> does not have a comparison operator, "<literal>=</literal>"
				will be added between the condition and the value).
			</para>
		</section>
		
		<section>
			<title>Grouping rows (GROUP BY)</title>
			
			<para>
				To add columns to the GROUP BY clause, use <function>Db_Query_Select->groupBy</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Select-groupBy">
				<funcprototype>
					<funcdef><type>Db_Query_Select</type> <function>Db_Query_Select->groupBy</function></funcdef>
					
					<paramdef><type>string</type>|<type>array</type> <parameter>$columns</parameter></paramdef>
					<paramdef choice="opt"><type>string</type> <parameter>$table</parameter> = <initializer>false</initializer></paramdef>
					<paramdef choice="opt"><type>boolean</type> <parameter>$table_is_aliased</parameter> = <initializer>false</initializer></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The <parameter>$columns</parameter> is <glossterm>identifier protected</glossterm>
				and is then added to the array.
			</para>
			
			<para>
				<parameter>$table</parameter> and <parameter>$table_is_aliased</parameter> controls wether
				to add a table alias in front of the columns (ie. "<literal>table_alias.column</literal>").
				<parameter>$table</parameter> is the table alias, and will be prefixed with the database
				prefix if <parameter>$table_is_aliased</parameter> is <symbol>false</symbol>.
			</para>
		</section>
		
		<section>
			<title>Limit and Offset</title>
			
			<funcsynopsis xml:id="funcref.Db_Query_Select-limit">
				<funcprototype>
					<funcdef><type>Db_Query_Select</type> <function>Db_Query_Select->limit</function></funcdef>
					
					<paramdef><type>int</type> <parameter>$limit</parameter></paramdef>
					<paramdef choice="opt"><type>int</type> <parameter>$offset</parameter> = <initializer>false</initializer></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<funcsynopsis xml:id="funcref.Db_Query_Select-offset">
				<funcprototype>
					<funcdef><type>Db_Query_Select</type> <function>Db_Query_Select->limit</function></funcdef>
					
					<paramdef><type>int</type> <parameter>$offset</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		</section>
		
		<section>
			<title>Issuing a COUNT() query</title>
			
			<para>
				COUNT() queries are quite common, hence were the <function>Db_Query_Select->count</function>
				method created.
				It temporarily modifies the current query object, making it count the number of rows instead
				of fetching a result set.
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Select-count">
				<funcprototype>
					<funcdef><type>int</type>|<type>false</type> <function>Db_Query_Select->count</function></funcdef>
					
					<paramdef choice="opt"><type>string</type> <parameter>$column</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				By default, <function>count</function> sends a "<literal>COUNT(1)</literal>" query,
				which counts all rows in a result set.
				This might not be satisfactory, so the <parameter>$column</parameter> parameter is there
				to replace the "<literal>1</literal>" within the COUNT() function (you can also
				add multiple columns by separating them by commas), <parameter>$columns</parameter>
				will be <glossterm>identifier protected</glossterm>.
			</para>
			
			<para>
				<symbol>false</symbol> can be returned in case of an error.
			</para>
			
			<example>
				<title>Couning a query and then fetching the data</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select();

$q->from('tracks');
$q->where('artist_id', $_GET['artist_id']);

// count a total to be able to determine the number of pages
$tot = $q->count();

// now limit and set offset to the correct page
$q->limit(10, $_GET['p'] * 10);

$r = $q->get();]]></programlisting>
			</example>
		</section>
		
		<section>
			<title>Getting the result</title>
			
			<para>
				To get the result, use the <function>Db_Query_Select->get</function> method:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Select-get">
				<funcprototype>
					<funcdef><type>Db_Result</type> <function>Db_Query_Select->get</function></funcdef>
					
					<void />
				</funcprototype>
			</funcsynopsis>
			
			<example>
				<title>Getting results from a select query</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select();

$r = $q->from('tracks')->get();]]></programlisting>
			</example>
		</section>
	</section>
	
	<section xml:id="chapter.query_builders.insert_queries">
		<title>INSERT Queries</title>
		
		<para>
			For the INSERT query objects, <classname>Db_Query_Insert</classname>,
			the table to insert the data into is already specified.
			So the only information that needs to be added to the object is the data
			to insert.
		</para>
		
		<section>
			<title>Adding data to insert</title>
			
			<para>
				To add data to the insert object, use <function>Db_Query_Insert->set</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Insert-set">
				<funcprototype>
					<funcdef><type>Db_Query_Insert</type> <function>Db_Query_Insert->set</function></funcdef>

					<paramdef><type>associative array</type> <parameter>$data</parameter></paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query_Insert</type> <function>Db_Query_Insert->set</function></funcdef>

					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef><type>scalar</type>|<type>Db_Query_Select</type> <parameter>$value</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The first variant enables you to add an <type>array</type> with data
				(column => value) which is merged into the current data contained in the object.
				The second variant just sets a single value to the value of <parameter>$value</parameter>.
			</para>
			
			<para>
				If <parameter>$value</parameter> (or the value of an associative array) is a
				<classname>Db_Query_Select</classname> object, then that query will be incorporated
				as a subquery.
			</para>
			
			<warning>
				<para>
					The subquery must only select one column, otherwise the database will raise an error.
				</para>
			</warning>
		</section>
		
		<section>
			<title>Inserting multiple rows simultaneously</title>
			
			<warning>
				<para>
					This might not be supported in all database servers, check if your database
					is supporting the correct syntax before use.
				</para>
			</warning>
			
			<para>
				RapidDataMapper has support for multi-row insertions by using the method
				<function>Db_Query_Insert->add</function> to add additional rows:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Insert-add">
				<funcprototype>
					<funcdef><type>Db_Query_Insert</type> <function>Db_Query_Insert->add</function></funcdef>

					<paramdef choice="opt"><type>associative array</type> <parameter>$data</parameter> = <initializer>false</initializer></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				This adds another internal row, which means that all subsequent calls to
				<function linkend="funcref.Db_Query_Insert-set">Db_Query_Insert->set</function>
				will populate the new row.
			</para>
			
			<para>
				The <parameter>$data</parameter> parameter is sent to
				<function linkend="funcref.Db_Query_Insert-set">Db_Query_Insert->set</function> if it is
				populated (after the new row has been created).
			</para>
		</section>
		
		<section>
			<title>Issuing an INSERT query</title>
			
			<para>
				An INSERT query is run by calling <function>Db_Query_Insert->execute</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Insert-execute">
				<funcprototype>
					<funcdef><type>int</type>|<type>false</type> <function>Db_Query_Insert->execute</function></funcdef>
					
					<void />
				</funcprototype>
			</funcsynopsis>
		</section>
		
		<section>
			<title><classname>Db_Query_Insert</classname> and no-escape</title>
			
			<para>
				If <function linkend="funcref.Db_Query-escape">Db_Query->escape</function> is set to
				false, then the <function linkend="funcref.Db_Query_Insert-set">Db_Query_Insert->set</function>
				method will not escape the <parameter>$value</parameter>, instead it will just be
				concatenated into the <token>VALUES</token> part of the INSERT query.
			</para>
			
			<note>
				<para>
					<classname>Db_Query_Insert</classname> does not inherit from <classname>Db_Query</classname>
					as it does not need the majority of the functionality.
				</para>
			</note>
		</section>
	</section>
	
	<section xml:id="chapter.query_builders.update_queries">
		<title>UPDATE Queries</title>
		
		<para>
			This object is just like the <classname>Db_Query_Insert</classname> objects,
			already pre-populated with the table to store the data in (made by
			<function linkend="funcref.Db_Connection-update">Db_Connection->update</function>).
			The greatest difference between the <classname>Db_Query_Insert</classname> and
			<classname>Db_Query_Update</classname> is that <classname>Db_Query_Update</classname>
			inherits from <classname>Db_Query</classname>; making it inherit all
			<link linkend="chapter.query_builders.conditions">Condition creating methods</link>.
		</para>
		
		<section>
			<title>Setting data</title>
			
			<para>
				The <function>Db_Query_Update->set</function> method works just like
				the equivalent method found in <classname>Db_Query_Insert</classname>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Update-set">
				<funcprototype>
					<funcdef><type>Db_Query_Update</type> <function>Db_Query_Update->set</function></funcdef>

					<paramdef><type>associative array</type> <parameter>$data</parameter></paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query_Update</type> <function>Db_Query_Update->set</function></funcdef>

					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef><type>scalar</type>|<type>Db_Query_Select</type> <parameter>$value</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The exception is that <classname>Db_Query_Update</classname> does not have an
				<function linkend="funcref.Db_Query_Insert-add">Db_Query_Insert->add</function> method.
				This means that the <function>Db_Query_Update->set</function> method always
				add the data to the same "row".
			</para>
		</section>
		
		<section>
			<title>Limiting the updates</title>
			
			<para>
				Limiting is made by calling the <function>Db_Query_Update->limit</function> method:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Update-limit">
				<funcprototype>
					<funcdef><type>Db_Query_Update</type> <function>Db_Query_Update->limit</function></funcdef>

					<paramdef><type>int</type> <parameter>$limit</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The <parameter>$limit</parameter> parameter contains the maximum number of rows that
				will be allowed to be modified by the query.
			</para>
		</section>
		
		<section>
			<title>Filtering what to update</title>
			
			<para>
				<classname>Db_Query_Update</classname> inherits all the filtering methods from
				<classname>Db_Query</classname>, see
				<link linkend="chapter.query_builders.conditions">SQL Conditions</link> on how
				to add conditions to the query.
			</para>
		</section>
		
		<section>
			<title>Issuing an UPDATE query</title>
			
			<para>
				Just as with INSERT queries you use the <function>Db_Query_Update->execute</function>
				method:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Update-execute">
				<funcprototype>
					<funcdef><type>int</type>|<type>false</type> <function>Db_Query_Update->execute</function></funcdef>
					
					<void />
				</funcprototype>
			</funcsynopsis>
		</section>
		
		<section>
			<title>Updating multiple tables in a single query</title>
			
			<warning>
				<para>
					This might not be supported in all database servers, check if your database
					is supporting the correct syntax before use.
				</para>
			</warning>
			
			<para>
				To update multiple tables, pass an array of table names as the second parameter
				to <function linkend="funcref.Db_Connection-update">Db_Connection->update</function>.
			</para>
			
			<example>
				<title>Updating multiple tables in one query</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->update(array('artist', 'track'));

$q->set('artists.name', $_POST['artist']);
$q->set('tracks.name', $_POST['track']);
$q->where('tracks.artist_id = artists.id')->where('tracks.id', $_POST['id']);

if($q->execute())
{
	echo 'Update was successful!';
}
// UPDATE `artists`, `tracks`
// SET `artists`.`name` = 'foo', `tracks`.`name` = 'Bar'
// WHERE `tracks`.`artist_id` = `artists`.`id` AND `tracks`.`id` = 4]]></programlisting>
			</example>
			
			<warning>
				<para>
					If you have columns which are identically named in two or more of the tables
					you are updating you have to prefix each of the columns with the table name
					in the calls to <function linkend="funcref.Db_Query_Update-set">Db_Query_Update->set</function>.
				</para>
			</warning>
		</section>
	</section>
	
	<section xml:id="chapter.query_builders.delete_queries">
		<title>DELETE Queries</title>
		
		<para>
			The <classname>Db_Query_Delete</classname> object is already pre-populated with two things
			when you get it from <function linkend="funcref.Db_Connection-delete">Db_Connection->delete</function>:
			tables to delete from and their aliases.
		</para>
		
		<section>
			<title>Adding another table to delete rows from</title>
			
			<para>
				To add another table to the query you can either use <function>Db_Query_Delete->from</function>
				or <function>Db_Query_Delete->join</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Delete-from">
				<funcprototype>
					<funcdef><type>Db_Query_Delete</type> <function>Db_Query_Delete->from</function></funcdef>
					
					<paramdef><type>string</type>|<type>array</type>|<type>Db_Query_Select</type> <parameter>$tables</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<funcsynopsis xml:id="funcref.Db_Query_Delete-join">
				<funcprototype>
					<funcdef><type>Db_Query_Delete</type> <function>Db_Query_Delete->join</function></funcdef>
					
					<paramdef><type>string</type>|<type>array</type>|<type>Db_Query_Select</type> <parameter>$table</parameter></paramdef>
					<paramdef><type>string</type> <parameter>$condition</parameter></paramdef>
					<paramdef choice="opt"><type>string</type> <parameter>$type</parameter> = "<initializer>left</initializer>"</paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The <function>Db_Query_Delete->join</function> and <function>Db_Query_Delete->from</function>
				work just like their <classname>Db_Query_Select</classname> counterparts,
				with the exception that they cannot select columns.
			</para>
			
			<para>
				These two methods will only add the table(s) to the query, but they will <emphasis>not</emphasis>
				have rows removed from them.
				This is useful when you need to filter by a relation or some other value which is not located
				in the table from which the rows should be deleted.
			</para>
			
			<para>
				To make the delete query also remove rows from one or several of the added tables,
				use <function>Db_Query_Delete->addDelete</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Delete-addDelete">
				<funcprototype>
					<funcdef><type>Db_Query_Delete</type> <function>Db_Query_Delete->addDelete</function></funcdef>
					
					<paramdef><type>string</type>|<type>array</type> <parameter>$tables</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The contents of the <parameter>$tables</parameter> parameter is added to the list of
				tables/aliases to delete rows from.
			</para>
			
			<warning>
				<para>
					Not all databases support multi-table deletes.
				</para>
				
				<para>
					Check with your database's manual before using them.
				</para>
			</warning>
		</section>
		
		<section>
			<title>Limiting the delete query</title>
			
			<para>
				Limiting is made by calling the <function>Db_Query_Delete->limit</function> method:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Delete-limit">
				<funcprototype>
					<funcdef><type>Db_Query_Delete</type> <function>Db_Query_Delete->limit</function></funcdef>

					<paramdef><type>int</type> <parameter>$limit</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The <parameter>$limit</parameter> parameter contains the maximum number of rows that
				will be allowed to be deleted by the query.
			</para>
		</section>
		
		<section>
			<title>Filtering what to delete</title>
			
			<para>
				<classname>Db_Query_Delete</classname> inherits all the filtering methods from
				<classname>Db_Query</classname>, see
				<link linkend="chapter.query_builders.conditions">SQL Conditions</link> on how
				to add conditions to the query.
			</para>
		</section>
		
		<section>
			<title>Issuing a DELETE query</title>
			
			<para>
				Just as with INSERT and UPDATE queries you use the <function>Db_Query_Delete->execute</function>
				method:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query_Delete-execute">
				<funcprototype>
					<funcdef><type>int</type>|<type>false</type> <function>Db_Query_Delete->execute</function></funcdef>
					
					<void />
				</funcprototype>
			</funcsynopsis>
		</section>
	</section>
	
	<section xml:id="chapter.query_builders.escaping">
		<title>Controlling escaping</title>
		
		<para>
			By default are all the data sent into the query builders either
			<glossterm linkend="glossary.escaping">escaped</glossterm>
			or <glossterm linkend="glossary.identifier_protection">identifier protected</glossterm>.
			To control escaping <classname>Db_Query</classname> and all its descendants has the
			<function>Db_Query->escape</function>:
		</para>
		
		<funcsynopsis xml:id="funcref.Db_Query-escape">
			<funcprototype>
				<funcdef><type>Db_Query</type> <function>Db_Query->escape</function></funcdef>
				
				<paramdef choice="opt"><type>bool</type> <parameter>$escape</parameter> = <initializer>true</initializer></paramdef>
			</funcprototype>
		</funcsynopsis>
		
		<para>
			<function>Db_Query->escape</function> will return the object it is located on, which means
			that if it is called on a <classname>Db_Query_Select</classname> object, that object instance
			will be returned.
		</para>
		
		<para>
			The setting that <function>Db_Query->escape</function> controls does not affect previous calls
			to the query object, so if you want to disable escaping for some parts and not for others,
			it is definitely possible.
		</para>
		
		<example>
			<title>Switching escaping on and off during construction of a single query</title>
			
			<programlisting language="php"><![CDATA[$q = Db::getConnection()->select();

$q->from('artists', 'name');

$q->escape(false);
$q->column('COUNT(tracks.id)');

$q->escape(true);
$q->join('tracks', 'tracks.artist_id = artists.id', array()); // no need to select columns
$q->groupBy('artists.name');

var_dump($q->getSQL());
// SELECT `t1`.`name`, COUNT(artists.id)
// FROM `artists` AS `t1`
// JOIN `tracks` AS `t2` ON `tracks`.`artist_id` = `artists`.`id`
// GROUP BY `artists`.`name`]]></programlisting>
		</example>
	</section>
	
	<section xml:id="chapter.query_builders.conditions">
		<title>The Different SQL Conditions</title>
		
		<para>
			Conditions are very common in SQL, and it is almost impossible to avoid them.
			As soon as you need to filter something you have to use them
			(unless you want to do it the slow way: load everything and then iterate in PHP).
		</para>
		
		<para>
			RapidDataMapper provides helper methods on the query objects to make it easy
			to both create the initial conditions but also to simplify the addition of
			extra conditions.
			The conditions do not have to be specified all at once, instead you can add
			them wherever the need arises.
		</para>
		
		<para>
			The code below dynamically adds a <token>LIKE</token> condition to a query when
			it is a "search request":
		</para>
		
		<example>
			<title>Adding additional WHERE conditions</title>
			
			<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

$q->where('artist', $_POST['name']);

if($search)
{
	$q->like('name', $_POST['search']);
}

$result = $q->get();]]></programlisting>
		</example>
		
		<section xml:id="chapter.query_builders.conditions.or">
			<title>Replacing AND with OR boolean operators</title>
			
			<para>
				All the conditions have their methods on the query building objects (except for INSERT which
				does not have the need) and the first parameter behaves the same on all of them:
				It is <glossterm>identifier protected</glossterm> and if it is prefixed by an OR ("<literal>or </literal>")
				then an <token>OR</token> operator will precede the condition instead of an <token>AND</token>.
			</para>

			<para>
				If there are no earlier conditions no boolean operator will be prepended, even if you
				explicitly write "<literal>or </literal>" before the column name.
			</para>

			<example>
				<title>Using OR operators</title>

				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

// this is very foolish, use Db_Query->whereIn() instead as it will be both faster on the PHP and database ends
foreach($_POST['artists'] as $artist)
{
	$q->where('or artist', $artist);
}]]></programlisting>
			</example>
		</section>
		
		<section xml:id="chapter.query_builders.conditions.where">
			<title>WHERE</title>
			
			<para>
				The <token>WHERE</token> condition is the most commonly used and also the one with
				the most features in the query builder. It can add the conditions in sequences,
				but it can also nest them in parenthesis and use <glossterm>subqueries</glossterm>.
			</para>
			
			<para>
				By default all the conditions and values sent to <function>Db_Query->where</function>
				will be identifier protected and escaped, respectively.
				The identifier protection will protect all the identifiers (to avoid both injection attacks
				and interference with database keywords) but it will preserve all conditional operators
				(eg. "<literal>=</literal>", "<literal>&lt;</literal>", "<literal>&gt;</literal>",
				"<literal>!=</literal>").
			</para>
			
			<para>
				To avoid escaping or identifier protection, use
				<link linkend="funcref.Db_Query-escape"><function>Db_Query->escape</function></link>
				to temporarily switch escaping off.
			</para>
			
			<para>
				Function synopsis for <function>Db_Query->where</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-where">
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->where</function></funcdef>
					
					<void />
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->where</function></funcdef>
					
					<paramdef><parameter>'or'</parameter></paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->where</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$condition</parameter></paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->where</function></funcdef>
					
					<paramdef><type>array</type> <parameter>$condition</parameter></paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->where</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$condition</parameter></paramdef>
					<paramdef choice="opt"><type>scalar</type> <parameter>$value</parameter></paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->where</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$condition</parameter></paramdef>
					<paramdef><type>Db_Query_Select</type> <parameter>$subquery</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<section>
				<title>Nesting WHERE conditions</title>
				
				<para>
					The first and second variants creates a nested list of conditions that will be wrapped in parenthesis.
					If the first parameter is empty (first variant), it will be preceded by <token>AND</token>
					if there are conditions before it.
					If the first parameter is equal to "<literal>or</literal>" (second variant) it will
					instead be preceded by <token>OR</token>.
				</para>
				
				<para>
					You can not only use <function>Db_Query->where</function> in the nested query
					(on the nested where object), but also
					<function linkend="funcref.Db_Query-whereIn">Db_Query->whereIn</function>,
					<function linkend="funcref.Db_Query-whereNotIn">Db_Query->whereNotIn</function> and
					<function linkend="funcref.Db_Query-like">Db_Query->like</function>.
				</para>
				
				<example>
					<title>Using nested WHERE conditions</title>
					
					<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

// store the nested variant in $nested
$nested = $q->where();

// no need to reassign it to $q again, it is already linked with the proper place in the WHERE stack in $q
$nested->where('artist', 'Within Temptation');
$nested->where('or artist', 'Skyfire');

// add another condition after the nested conditions
$q->like('name', 'intro');

$r = $q->get();
// SELECT t1.* FROM tracks WHERE (`artist` = 'Within Temptation' OR `artist` = 'Skyfire') AND `name` LIKE '%intro%'

// Or the same query using method-chaining (end() returns the parent object):
$r = Db::getConnection()->select()
		->from('tracks')
		->where()
			->where('artist', 'Within Temptation')
			->where('or artist', 'Skyfire')
		->end()
		->like('name', 'intro')
	->get();]]></programlisting>
				</example>
			</section>
			
			<section>
				<title>Conditions between two columns</title>
				
				<para>
					The third variant is a lot simpler, it will simply append the <parameter>$condition</parameter>
					to the WHERE stack (but it will still parse the OR condition if present, and also
					protect the identifiers provided escaping is on):
				</para>
				
				<example>
					<title>Adding conditions between different columns</title>
					
					<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

$q->where('name = artist'); // WHERE `name` = `artist`

$r = $q->get();]]></programlisting>
				</example>
			</section>
			
			<section>
				<title>Conditions between column and a value</title>
				
				<para>
					To add a condition which compares a column with a specified value, you just supply a
					column name as the first parameter (<parameter>$condition</parameter>, with optional
					comparison operator) and the value to compare with as the <parameter>$value</parameter> parameter.
				</para>
				
				<para>
					If the <parameter>$condition</parameter> does not have a condition at the end, an equal
					sign ("<literal>=</literal>") will be appended. The check for a boolean <token>OR</token>
					operator will also be made (see
					<link linkend="chapter.query_builders.conditions.or">Replacing AND with OR boolean operators</link>).
				</para>
				
				<para>
					If <function linkend="funcref.Db_Query-escape">Db_Query->escape</function> is set to <symbol>false</symbol>,
					<parameter>$condition</parameter> will not be identifier protected (conditions will still be
					appended and <token>OR</token> will also be parsed, and if a condition is missing at the
					end of <parameter>$condition</parameter>, an "<literal>=</literal>" will still be appended)
					and <parameter>$value</parameter> will be concatenated (no escaping) and then appended to the WHERE
					stack.
				</para>
				
				<example>
					<title>Comparing column to a value</title>
					
					<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

$q->where('artist', 'Wintersun'); // `artist` = 'Wintersun'
$q->where('or artist =', 'Within Temptation'); // OR `artist` = 'Within Temptation'
$q->where('plays >', 23); // AND `plays` > 23

// no escaping:
$q->escape(false);
$q->where('or LOWER(name)', 'something \' not escaped');
// OR LOWER(name) = something ' not escaped
// recommending this instead:
$q->where('or LOWER(name)', Db::getConnection()->escape('something \' escaped'));
// OR LOWER(name) = 'something \' escaped'

// switching escaping to on (not strictly needed in this case,
// but good to do if you eg. want to insert more code after the unescaped condition):
$q->escape(true);

$r = $q->get();]]></programlisting>
				</example>
			</section>
			
			<section>
				<title>Condition with a subquery</title>
				
				<para>
					You can also make a condition that compares a column to a single value returned
					by a subquery (notice: SINGLE value, otherwise it is a high probability that the
					database will complain).
				</para>
				
				<para>
					It will work the same as if you compare a column with a value, only that the value
					is substituted with the subquery.
				</para>
				
				<example>
					<title>Comparing a column with a subquery</title>
					
					<programlisting language="php"><![CDATA[$db = Db::getConnection();

$q   = $db->select()->from('tracks');
$sub = $db->select()->from('tracks', 'name')->where('plays >', 23)->limit(1);

$q->where('artist', $sub); // `artist` = (SELECT `name` FROM `tracks` WHERE `plays` > 23 LIMIT 1)

$r = $q->get();]]></programlisting>
				</example>
			</section>
		</section>
		
		<section xml:id="chapter.query_builders.conditions.where_in">
			<title>WHERE IN</title>
			
			<para>
				The WHERE IN condition matches a single column against a list of values, matching if
				the column matches at least one of the values.
				The WHERE IN condition is added to a query by calling <function>Db_Query->whereIn</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-whereIn">
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->whereIn</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef><type>array</type> <parameter>$values</parameter></paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->whereIn</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef><type>Db_Query_Select</type> <parameter>$values</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				As usual you can prepend an <token>or</token> to the column to concatenate it
				with an OR to the previous condition.
			</para>
			
			<example>
				<title>Using WHERE IN with a PHP array</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

$titles = array('Ten Leagues Beneath Contempt', 'Genesis', 'Loot Burn Rape Kill Repeat');

$q->whereIn('name', $titles); // WHERE `name` IN ('Ten Leagues Beneath Contempt', 'Genesis', 'Loot Burn Rape Kill Repeat')

$r = $q->get();]]></programlisting>
			</example>
			
			<example>
				<title>Using subqueries with WHERE IN</title>
				
				<programlisting language="php"><![CDATA[$db = Db::getConnection();

$q  = $db->select()->from('artists');

$q2 = $db->select()->from('tracks', 'name'); // important to only select one column
$q2->escape(false)->having('COUNT(name) >', 2)->groupBy('name');

$q->whereIn('name', $q2); // WHERE `name` IN (SELECT `name` FROM `tracks` HAVING COUNT(name) > 2 GROUP BY `name`)

$r = $q->get();]]></programlisting>
			</example>
			
			<para>
				If the <function linkend="funcref.Db_Query-escape">Db_Query->escape</function> method
				has set escaping to <symbol>false</symbol>, <parameter>$column</parameter> will not be identifier
				protected (but "<literal>OR </literal>" is still parsed).
			</para>
			
			<example>
				<title>Using WHERE IN without escaping the column</title>
				
				<programlisting language="php"><![CDATA[$q = Db:getConnection()->select()->from('tracks');

$q->escape(false);
$q->where('LOWER(name)', $titles);
// WHERE LOWER(name) IN (some list goes here)

$r = $q->get();]]></programlisting>
			</example>
		</section>
		
		<section xml:id="chapter.query_builders.conditions.where_not_in">
			<title>WHERE NOT IN</title>
			
			<para>
				This is a variant of the WHERE IN condition, but instead of searching for matches
				to the supplied list it searches for columns NOT matching the list.
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-whereNotIn">
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->whereNotIn</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef><type>array</type> <parameter>$values</parameter></paramdef>
				</funcprototype>
				
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->whereNotIn</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef><type>Db_Query_Select</type> <parameter>$values</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		</section>
		
		<section xml:id="chapter.query_builders.conditions.like">
			<title>LIKE</title>
			
			<para>
				To add a LIKE search condition, use <function>Db_Query->like</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-like">
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->like</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef><type>array</type> <parameter>$match</parameter></paramdef>
					<paramdef choice="opt"><type>string</type> <parameter>$side</parameter> = "<initializer>both</initializer>"</paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				The <parameter>$column</parameter> parameter is filtered for "<literal>or </literal>" and also identifier
				protected.
				<parameter>$match</parameter> is escaped, with the addition that LIKE wildcards also are escaped
				(eg. in MySQL are "<literal>%</literal>" and "<literal>_</literal>" escaped), to prevent
				a too high workload on the server.
			</para>
			
			<para>
				The <parameter>$side</parameter> parameter dictates on which side the "<literal>%</literal>"
				wildcards should be placed ("<literal>%</literal>" matches any number of characters of any type).
				The possible values are "<literal>left</literal>", "<literal>right</literal>"
				and "<literal>both</literal>".
			</para>
			
			<example>
				<title>Using Db_Query->like</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnection()->select()->from('tracks');

$q->like('name', 'loss', 'left'); // WHERE `name` LIKE '%loss'

$q->escape(false);
$q->like('or LOWER(artist)', 'dark'); // OR LOWER(artist) LIKE '%dark%'

$r = $q->get();]]></programlisting>
			</example>
		</section>
		
		<section>
			<title>WHERE IS (NOT?) NULL</title>
			
			<para>
				To filter by the presence of a value in a column (ie. if it is <symbol>null</symbol> or not),
				use <function>Db_Query->whereIsNull</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-whereIsNull">
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->whereIsNull</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
					<paramdef choice="opt"><type>boolean</type> <parameter>$yes</parameter> = <initializer>true</initializer></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				This will add a IS NULL condition based on <parameter>$column</parameter> to the
				WHERE part of the query (the "<literal>OR</literal>" filter still applies on <parameter>$column</parameter>).
			</para>
			
			<para>
				The <parameter>$yes</parameter> parameter is there to tell if <function>whereIsNull</function> should
				check for <symbol>null</symbol> or the absence of <symbol>null</symbol>.
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-whereIsNotNull">
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->whereIsNotNull</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				This variant just adds a IS NOT NULL condition, behaves exactly like <function>Db_Query->whereIsNull</function>
				with <parameter>$yes</parameter> set to <symbol>true</symbol>.
			</para>
		</section>
		
		<section xml:id="chapter.query_builders.conditions.bind_where">
			<title>Fragments with parameters added to WHERE</title>
			
			<para>
				Sometimes you would like to add a large prewritten condition (or list of conditions) to the WHERE part
				of the query, but still be able to escape all the values.
				RapidDataMapper provides a way for you to do that, where it only replaces certain placeholders
				with the escaped values.
				This is also called prepared statements with bound parameters.
			</para>
			
			<para>
				(Actually, it is not, but it works exactly like it on the PHP side.)
			</para>
			
			<para>
				This works like the <parameter>$binds</parameter> parameter to
				<function linkend="funcref.Db_Connection-query">Db_Connection->query</function>,
				with the exception that it only appends it to the WHERE part of the query.
				It also parses any prepended "<literal>or </literal>" on the <parameter>$condition</parameter>
				parameter.
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Query-bindWhere">
				<funcprototype>
					<funcdef><type>Db_Query</type> <function>Db_Query->bindWhere</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$condition</parameter></paramdef>
					<paramdef><type>array</type> <parameter>$binds</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<example>
				<title>Using bound parameters in the WHERE part of a query builder</title>
				
				<programlisting language="php"><![CDATA[$q = Db::getConnnection()->select()->from('tracks');

// requires two parameters, first = name, second = artist
$q->bindWhere('LOWER(name) = ? OR SUBSTR(name, 3) = SUBSTR(artist, -3) AND artist = ?', $_POST);

$r = $q->get();]]></programlisting>
			</example>
		</section>
	</section>
</chapter>