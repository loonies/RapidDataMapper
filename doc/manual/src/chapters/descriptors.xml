<?xml version="1.0" encoding="utf-8"?>
<chapter
	version="5.0"
	xml:id="chapter.descriptors"
	xml:lang="en"
	xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:db="http://docbook.org/ns/docbook"
	>
	
	<title>Descriptors</title>
	
	<section>
		<title>Introduction</title>
		
		<para>
			In RapidDataMapper there are no configuration files, instead it uses <abbrev>PHP</abbrev> objects
			for storing the configuration.
			This enables a lot of customization as classes makes it possible to modify their behaviour by sub-classing.
		</para>
		
		<para>
			The objects which contain the configurations are called descriptors, this is because
			they describe the mapping.
			All descriptors are either instances of <classname>Db_Descriptor</classname>
			or instances of a descendant class.
		</para>
		
		<para>
			The <classname>Db_Descriptor</classname> class contains a lot of default values and assumptions,
			some of them are modifiable by changing properties or calling methods,
			others are modifiable by overriding one or several methods in a child class.
			This not only enables a user to have a simple and powerful way to configure a mapping,
			it also enables the user to create his own default descriptor settings with a subclass which
			is then used as the base class for his descriptors.
		</para>
		
		<para>
			There are several ways in which a descriptor can be created.
			Firstly you can just create an instance of <classname>Db_Descriptor</classname> and
			then configure it directly.
			Secondly, you can create a subclass which then configures itself in the constructor
			(recommended for most purposes).
			Thirdly, and this can be combined with the previous two, you create a subclass of
			<classname>Db_Descriptor</classname> which redefines some defaults, making for less code
			to be repeated in the final descriptor instances.
		</para>
		
		<example>
			<title>Creating Descriptors in three ways</title>
			
			<programlisting language="php"><![CDATA[// # 1:
$d = new Db_Descriptor();
$d->setClass('Classname');
// ...

// # 2:
class FooDescriptor extends Db_Descriptor
{
	function __construct()
	{
		$this->setClass('Classname');
		// ...
	}
}

// # 3:
class Lib_Descriptor extends Db_Descriptor
{
	// make the table become singular_tbl
	public function getTable()
	{
		return empty($this->table) ? $this->getSingular().'_tbl' : $this->table;
	}
}

class BazDescriptor extends Lib_Descriptor
{
	function __construct()
	{
		$this->setClass('Someclass');
		// ...
	}
}

// or create an instance of Lib_Descriptor]]></programlisting>
		</example>
	</section>
	
	<section xml:id="chapter.descriptors.associating">
		<title>Associating descriptors with the class to be mapped</title>
		
		<para>
			There are several ways to add descriptors, which one that is suitable depends on your preferences
			and how the project is set up (<glossterm>autoloaders</glossterm>, configuration files,
			folder structure <abbrev>etc</abbrev>.).
		</para>
		
		<para>
			All loaded descriptors are stored in an internal array, which means that once a descriptor
			is loaded, that instance is the descriptor for that class permanently (until the restart of the PHP
			thread running, so the static <classname>Db</classname> class is reloaded).
		</para>
		
		<para>
			If all tries to load a descriptor fails, a <classname>Db_DescriptorException</classname>
			is thrown.
		</para>
		
		<para>
			Here are the different methods of associating a class as the <glossterm>descriptor</glossterm> for a class
			to be mapped (ordered after precedence, RapidDataMapper tries to find a descriptor using the first
			listed method and then the second and so on):
		</para>
		
		<section>
			<title>Using Db::addDescriptor</title>
			
			<para>
				This method is suitable when you eg. generate a descriptor on the fly
				(ie. creating an instance of <classname>Db_Descriptor</classname> and then configure it
				for the mapping) or want to make another descriptor class take precedence over another
				which would be loaded by any of the other methods (eg. you need a special variant of the
				descriptor. NOTE: This requires the <function>Db::compileMappers</function> setting to
				be set to <symbol>false</symbol> as there can only be one compiled mapper instance per
				class to map.).
			</para>
			
			<para>
				<function>Db::addDescriptor</function> takes a <classname>Db_Descriptor</classname>
				instance and adds it to the internal array of descriptors.
				The <function>Db::getDescriptor</function> method always checks this array first
				to get the descriptor for the descriptor instance, which makes this method
				(<function>Db::addDescriptor</function>) have the highest precedence.
				The descriptors in this array are assigned by which class name they map
				(ie. what <function>Db_Descriptor->getClass</function> says it maps).
			</para>
			
			<para>
				If a class already has a loaded descriptor instance, <function>Db::addDescriptor</function>
				will throw a <classname>RuntimeException</classname>.
			</para>
			
			<funcsynopsis xml:id="funcref.Db-addDescriptor">
				<funcprototype>
					<funcdef><type>void</type> <function>Db::addDescriptor</function></funcdef>

					<paramdef><type>Db_Descriptor</type> <parameter>$descriptor</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<example>
				<title>Creating and assigning a descriptor on the fly</title>
				
				<programlisting language="php"><![CDATA[$d = new Db_Descriptor();

$d->setClass('Foobar');

$d->add($d->newPrimaryKey('id'));

foreach($columns as $c)
{
	$d->add($d->newColumn($c));
}

Db::addDescriptor($d);

$f = Db::find('Foobar')->get();]]></programlisting>
			</example>
		</section>
		
		<section>
			<title>Using a callback to return the appropriate descriptor</title>
			
			<para>
				This method uses a <glossterm>callback</glossterm> to fetch the proper descriptor instance.
			</para>
			
			<para>
				See chapter <link linkend="chapter.alternatives_to_the_db_descriptor">Alternatives to the Db_Descriptor</link>
			</para>
			
			<example>
				<title>Using XML configurations as the descriptors</title>
				
				<para>
					Firstly, create a directory for the configuration files
					(somewhere suitable, where PHP can read the files).
					Then add XML configuration files in that directory,
					for their format and naming, check
					<link linkend="chapter.alternatives_to_the_db_descriptor.xml">Alternatives to the Db_Descriptor: XML</link>.
				</para>
				
				<programlisting language="php"><![CDATA[// this is hypothetical syntax, as the Db_DescriptorLoader_*
// classes still needs to be written:

Db::setDescriptorLoader(array(new Db_DescriptorLoader_Xml('path/to/config/dir'), 'getDescriptor'));

// try to fetch an object which is described by an XML file
$o = Db::find('Foobar')->getOne();]]></programlisting>
			</example>
		</section>
		
		<section>
			<title>Using a class named classname + "<literal>Descriptor</literal>"</title>
			
			<para>
				This will probably be the most common method of loading the descriptors, which is to be
				used when using an <glossterm>autoloader</glossterm> to fetch the classes which are
				to be mapped.
				It makes it easy, as the descriptors will be stored in the same directory as the
				classes they map.
				Their filename will also be almost identical to the filename that they map, with
				the addition of "<literal>Descriptor</literal>" before the "<literal>.php</literal>"
				(depends on the autoloader).
			</para>
			
			<para>
				<function>Db::getDescriptor</function> tries to see if the class exists, and also
				tries to autoload it (by using <function>class_exists</function>).
				If the class is found, an instance is created and then used as the descriptor for the
				class to map.
			</para>
			
			<example>
				<title>Using class names to assign descriptors</title>
				
				<programlisting language="php"><![CDATA[// Preferably, this class should be defined in a separate file which is autoloaded.
// It makes for less loaded files when using compiled mappers (because the descriptors aren't needed).
class FoobarDescriptor extends Db_Descriptor
{
	public function __construct()
	{
		$this->setClass('Foobar');
		
		$this->add($this->newPrimaryKey('id'));
		$this->add($this->newColumn('title'));
		// ...
	}
}

echo Db::find('Foobar')->count();]]></programlisting>
			</example>
		</section>
		
		<section>
			<title>Using the Db::setDescriptorDirectory to load PHP files from a directory</title>
			
			<para>
				This method will probably be used in projects which does not use an <glossterm>autoloader</glossterm>,
				mainly because it fits more with their style: defining directories to contain specific files,
				classes and helper methods and then loading them with the help of <function>file_exists</function>
				and <function>include</function>.
			</para>
			
			<para>
				This is what <function>Db::getDescriptor</function> does if it cannot find a class with any of
				the above mentioned methods; tries to find a file with the same name as the class
				(+ "<literal>.php</literal>") and if the file exists: <function>require</function>s it and then
				tries to instantiate a class with the name of classname + "<literal>Descriptor</literal>".
			</para>
			
			<para>
				Use <function linkend="funcref.Db-setDescriptorDirectory">Db::setDescriptorDirectory</function>
				to set the path to the folder which contain the files with the descriptors.
			</para>
		</section>
	</section>
	
	<section>
		<title>Getting the descriptor which is mapped to a certain class</title>
		
		<para>
			To see which descriptor instance that a certain class is using for the mapping,
			use the <function>Db::getDescriptor</function>.
			This method will return a loaded descriptor instance, and if it isn't,
			it will try to load it with the steps shown in the section above.
		</para>
		
		<funcsynopsis xml:id="funcref.Db-getDescriptor">
			<funcprototype>
				<funcdef><type>Db_Descriptor</type> <function>Db::getDescriptor</function></funcdef>
				
				<paramdef><type>string</type> <parameter>$class_name</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
		
		<para>
			If a descriptor is not found, a <classname>Db_DescriptorException</classname>
			will be thrown.
		</para>
		
		<example>
			<title>Checking if a class has a descriptor, and if so, which table the class is mapped to</title>
			
			<programlisting language="php"><![CDATA[try
{
	$d = Db::getDescriptor('Foobar');
	
	echo sprintf('Class Foobar is mapped to the table %s.', $d->getTable());
}
catch(Db_DescriptorException $e)
{
	echo sprintf('Failed to get a descriptor for the class %s', $e->getClassName());
}]]></programlisting>
		</example>
	</section>
	
	<section>
		<title>Mapping classes to tables</title>
		
		<para>
			First, you create an instance of Db_Descriptor; either a subclass which is automatically instantiated by
			RapidDataMapper or a plain instance which you then send to
			<function linkend="funcref.Db-addDescriptor">Db::addDescriptor</function>.
			This instance needs to know which class it describes, otherwise it is useless,
			which is set using the <function>Db_Descriptor->setClass</function> method:
		</para>
		
		<funcsynopsis xml:id="funcref.Db_Descriptor-setClass">
			<funcprototype>
				<funcdef><type>Db_Descriptor</type> <function>Db_Descriptor->setClass</function></funcdef>
				
				<paramdef><type>string</type> <parameter>$class_name</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
		
		<para>
			(This method, an many other setter-methods of the <classname>Db_Descriptor</classname> supports
			<glossterm>method-chaining</glossterm>.)
		</para>
		
		<para>
			By default is the class attribute used as a base for the following settings:
			singular name (name used to refer to the class in singular, eg.
			<link linkend="chapter.relations">Relations</link> and their foreign keys),
			table name, and finally factory (the code piece which is used to create a new instance of the class when
			fetching data. All these values are constructed from the value supplied to
			<function>Db_Descriptor->setClass</function> and can be changed;
			either through their setters or through replacing their getter methods.
		</para>
		
		<table>
			<title>Class - Table mapping settings</title>
			
			<tgroup cols="5">
				<thead>
					<row>
						<entry>Name</entry>
						<entry>Setter</entry>
						<entry>Getter</entry>
						<entry>Default</entry>
						<entry>Description</entry>
					</row>
				</thead>
				
				<tbody>
					<row>
						<entry>class</entry>
						<entry><function>setClass</function>(<type>string</type> <parameter>$class_name</parameter>)</entry>
						<entry><type>string</type> <function>getClass</function>()</entry>
						<entry>REQUIRED</entry>
						<entry>
							The class name the current descriptor describes.
						</entry>
					</row>
					
					<row>
						<entry>singular</entry>
						<entry><function>setSingular</function>(<type>string</type> <parameter>$singular</parameter>)</entry>
						<entry><type>string</type> <function>getSingular</function>()</entry>
						<entry>lowercase of classname</entry>
						<entry>
							The name which is use to refer to the class in a singular fashion in queries and
							also used as a base for the relations' foreign keys
						</entry>
					</row>
					
					<row>
						<entry>table</entry>
						<entry><function>setTable</function> (<type>string</type> <parameter>$table</parameter>)</entry>
						<entry><type>string</type> <function>getTable</function>()</entry>
						<entry>plural of the singular setting</entry>
						<entry>
							The table name of the database table to which the class should be mapped to.
						</entry>
					</row>
					
					<row>
						<entry>factory</entry>
						<entry><function>setFactory</function> (<type>string</type> <parameter>$factory</parameter>)</entry>
						<entry><type>string</type> <function>getFactory</function>()</entry>
						<entry>"<literal>new</literal> " + class name</entry>
						<entry>
							The code piece to add after an equal sign ("<literal>=</literal>") but before the
							semicolon ("<literal>;</literal>") which is used to create a new object instance.
						</entry>
					</row>
					
					<row>
						<entry>database connection name</entry>
						<entry><function>setConnectionName</function> (<type>string</type> <parameter>$connection_name</parameter>)</entry>
						<entry><type>string</type> <function>getConnectionName</function>()</entry>
						<entry>
							"" (ie. the default database connection or if a connection has been specified by
							<function>setConnection</function>, that is used.
						</entry>
						<entry>
							The database connection to which the class should be mapped.
						</entry>
					</row>
					
					<row>
						<entry>database connection</entry>
						<entry><function>setConnection</function> (<type>Db_Connection</type> <parameter>$connection_object</parameter>)</entry>
						<entry><type>Db_Connection</type> <function>getConnection</function>()</entry>
						<entry>
							Default connection or the connection specified by <function>setConnectionName</function>.
						</entry>
						<entry>
							The <classname>Db_Connection object</classname> to use when mapping the
							class to the database.
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
		
		<para>
			As listed in the table; it is also possible to map the classes to several different connections.
		</para>
		
		<para>
			It is not always that the <classname>Db_Inflector</classname> can pluralize the singular name properly.
			If that is the case (you can easily see this by testing with
			"<literal>echo Db::getDescriptor('class name')->getTable();</literal>"),
			then use <function>Db_Descriptor->setTable</function> to set the correct table name.
		</para>
		
		<example>
			<title>Adjusting singular, table name and factory of table mappings</title>
			
			<programlisting language="php"><![CDATA[// We're doing it the short way, to easily show how it works
$d = new Db_Descriptor();

// Exceptions are thrown when class is not set:
// $d->getClass();
// $d->getSingular();
// $d->getTable();
// $d->getFactory();

$d->setClass('Track_obj');

echo $d->getClass();    // Track_obj
echo $d->getSingular(); // track_obj
echo $d->getTable();    // track_objs
echo $d->getFactory();  // new Track_obj

$d->setSingular('track');

echo $d->getClass();    // Track_obj
echo $d->getSingular(); // track
echo $d->getTable();    // tracks
echo $d->getFactory();  // new Track_obj

$d->setTable('track_tbl');

echo $d->getClass();    // Track_obj
echo $d->getSingular(); // track
echo $d->getTable();    // track_tbl
echo $d->getFactory();  // new Track_obj

$d->setFactory('Track_obj::create()');

echo $d->getClass();    // Track_obj
echo $d->getSingular(); // track
echo $d->getTable();    // track_tbl
echo $d->getFactory();  // Track_obj::create()]]></programlisting>
		</example>
	</section>
	
	<section>
		<title>Mapping properties to columns</title>
		
		<para>
			To map a PHP property to a database column, RapidDataMapper also uses a kind of descriptor
			for the columns themselves: the <classname>Db_Descriptor_Column</classname> class.
			Each instance of the <classname>Db_Descriptor_Column</classname> not only controls which property is
			mapped to which column, but it also also controls typecasting, column SELECT string, data type,
			if it can be updated, if it can be inserted and a lot more.
		</para>
		
		<section>
			<title>Creating a property - column descriptor</title>
			
			<para>
				To create an object describing a property - column mapping you use the
				<function>Db_Descriptor->newColumn</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Descriptor-newColumn">
				<funcprototype>
					<funcdef><type>Db_Descriptor_Column</type> <function>Db_Descriptor->newColumn</function></funcdef>
					
					<paramdef><type>string</type> <parameter>$column_name</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				This method creates an instance of the <classname>Db_Descriptor_Column</classname>
				(or a descendant if the <function>Db_Descriptor->newColumn</function> has been replaced)
				which you then can configure further if needed.
				The created instance is associated with the <classname>Db_Descriptor</classname>
				instance that created it, but it is not yet present in the internal column listing.
			</para>
			
			<para>
				To add the <classname>Db_Descriptor_Column</classname> instance to the
				<classname>Db_Descriptor</classname> instance's column list, use
				<function linkend="funcref.Db_Descriptor-add">Db_Descriptor->add</function>:
			</para>
			
			<example>
				<title>Assigning a property - column descriptor to a table descriptor</title>
				
				<programlisting language="php"><![CDATA[class FooDescriptor extends Db_Descriptor
{
	function __construct()
	{
		$this->setClass('Foo');
		
		$this->add($this->newColumn('example_column'));
	}
}]]></programlisting>
			</example>
			
			<para>
				The <function>Db_Descriptor->add</function> method is used for adding not only columns
				(<classname>Db_Descriptor_Column</classname>), but also <glossterm>primary keys</glossterm>
				(<classname>Db_Descriptor_PrimaryKey</classname>) and reltions
				(<classname>Db_Descriptor_Relation</classname>).
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Descriptor-add">
				<funcprototype>
					<funcdef><type>Db_Descriptor</type> <function>Db_Descriptor->add</function></funcdef>
					
					<paramdef>
						<type>Db_Descriptor_Column</type>|<type>Db_Descriptor_PrimaryKey</type>|<type>Db_Descriptor_Relation</type>|<type>array</type> <parameter>$object</parameter>
					</paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				It enables <glossterm>method chaining</glossterm> as it returns the same instance as the one
				used in the call to <function>Db_Descriptor->add</function>.
				It can also take an array of the previously mentioned three classes.
			</para>
		</section>
		
		<section>
			<title>Configuring a property - column mapping</title>
			
			<para>
				
			</para>
			
			<table>
				<title>Settings for a column descriptor (<classname>Db_Descriptor_Column</classname>)</title>
				
				<tgroup cols="5">
					<thead>
						<row>
							<entry>Name</entry>
							<entry>Setter</entry>
							<entry>Getter</entry>
							<entry>Default</entry>
							<entry>Description</entry>
						</row>
					</thead>

					<tbody>
						<row>
							<entry>column</entry>
							<entry><function>setColumn</function>(<type>string</type> <parameter>$column</parameter>)</entry>
							<entry><type>string</type> <function>getColumn</function></entry>
							<entry>REQUIRED</entry>
							<entry>
								The column name to which the property is mapped to.
							</entry>
						</row>
						
						<row>
							<entry>property</entry>
							<entry><function>setProperty</function>(<type>string</type> <parameter>$property</parameter>)</entry>
							<entry><type>string</type> <function>getProperty</function></entry>
							<entry>name of the column</entry>
							<entry>
								The name of the property to which the database column is mapped to.
							</entry>
						</row>
						
						<row>
							<entry>is_insertable</entry>
							<entry><function>setInsertable</function>(<type>boolean</type> <parameter>$value</parameter>)</entry>
							<entry><type>boolean</type> <function>isInsertable</function></entry>
							<entry><symbol>true</symbol></entry>
							<entry>
								If the column should be allowed to be used when constructing INSERT statements
								in <function linkend="funcref.Db-save">Db::save</function>.
							</entry>
						</row>
						
						<row>
							<entry>is_updatable</entry>
							<entry><function>setUpdatable</function>(<type>boolean</type> <parameter>$value</parameter>)</entry>
							<entry><type>boolean</type> <function>isUpdatable</function></entry>
							<entry><symbol>true</symbol></entry>
							<entry>
								If the column should be allowed to be used when constructing UPDATE statements
								in <function linkend="funcref.Db-save">Db::save</function>.
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			
			<note>
				Datatype and type-casting features are not done as of version 0.5.
				It will be added at a later stage and then it will convert it from and to correct PHP datatypes.
			</note>
		</section>
		
		<section>
			<title>Replacing the <classname>Db_Descriptor_Column</classname></title>
			
			<para>
				The <classname>Db_Descriptor</classname> uses the
				<link linkend="design_patterns.template_method">Template Method</link> design pattern combined
				with <link linkend="design_patterns.factory_method">Factory Method</link> which makes it very
				easy to move the original descriptor code to a new descendant of <classname>Db_Descriptor</classname>
				which uses alternative classes for describing the columns (eg. for replacing the default
				naming conventions).
			</para>
			
			<para>
				To replace the <classname>Db_Descritor_Column</classname> class with a custom descendant class,
				override the <function>Db_Descriptor->newColumn</function>:
			</para>
			
			<example>
				<title>Replacing the <classname>Db_Descriptor_Column</classname> class used by a descriptor</title>
				
				<programlisting language="php"><![CDATA[class MyDescriptor extends Db_Descriptor
{
	public function newColumn($name)
	{
		$c = new MyColumn(); // this is the class name of the column descriptor
		$c->setColumn($name);
		
		return $c;
	}
}]]></programlisting>
			</example>
		</section>
	</section>
	
	<section>
		<title>The primary keys</title>
		
		<para>
			The primary keys are described almost like normal columns are, with the exception that they
			use another descriptor class: <classname>Db_Descriptor_PrimaryKey</classname>.
			This class is a descendant of <classname>Db_Descriptor_Column</classname>, but contains some
			extra logic and changed default values just for primary keys.
		</para>
		
		<para>
			To create a primary key object, use <function>Db_Descriptor->newPrimaryKey</function>:
		</para>
		
		<funcsynopsis xml:id="funcref.Db_Descriptor-newPrimaryKey">
			<funcprototype>
				<funcdef><type>Db_Descriptor_PrimaryKey</type> <function>Db_Descriptor->newPrimaryKey</function></funcdef>
				
				<paramdef><type>string</type> <parameter>$column_name</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
		
		<para>
			Then you use <function linkend="funcref.Db_Descriptor-add">Db_Descriptor->add</function> to add the
			primary key descriptor to the descriptor.
		</para>
		
		<section>
			<title>Differences between <classname>Db_Descriptor_Column</classname> and <classname>Db_Descriptor_PrimaryKey</classname></title>
			
			<itemizedlist>
				<listitem>
					<para>
						By default are primary keys not updatable.
					</para>
					
					<para>
						Once you have inserted a row into the database, it is not meant that you should be
						able to change the value of the primary key.
					</para>
					
					<para>
						To change this, use <function>Db_Descriptor_PrimaryKey->setUpdatable</function>.
					</para>
				</listitem>
				
				<listitem>
					<para>
						The keys can populate themselves upon insert, depending on the key type.
						For example, the AUTO_INCREMENT variant uses the
						<function linkend="funcref.Db_Connection-insertId">Db_Connection->insertId()</function>
						method to fetch the generated int from the database. 
					</para>
				</listitem>
				
				<listitem>
					<para>
						The code generated to handle inserting and updating the row in the database can be
						radically different in several aspects, as specific logic applies to primary keys.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		
		<section>
			<title>Setting type of primary key</title>
			
			<para>
				The <classname>Db_Descriptor_PrimaryKey</classname> class has support for several types of
				primary keys, which perform different logic during row creation.
			</para>
			
			<para>
				To change the type of primary key, use <function>Db_Descriptor_PrimaryKey->setPkType</function>:
			</para>
			
			<funcsynopsis xml:id="funcref.Db_Descriptor_PrimaryKey-setPkType">
				<funcprototype>
					<funcdef><type>Db_Descriptor_PrimaryKey</type> <function>Db_Descriptor_PrimaryKey->setPkType</function></funcdef>
					
					<paramdef><type>int</type> <parameter>$type</parameter></paramdef>
					<paramdef choice="opt"><type>mixed</type> <parameter>$options</parameter> = <symbol>false</symbol></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<para>
				This method takes a constant defined in the <classname>Db_Descriptor</classname> class as
				the first parameter (a list of the constants can be found below in this section).
				The second parameter (<parameter>$options</parameter>) is for use with not yet
				created primary key types.
			</para>
			
			<para>
				Currently there are two types of primary keys supported:
			</para>
			
			<section>
				<title>Db_Descriptor::AUTO_INCREMENT</title>
				
				<para>
					This type uses the AUTO_INCREMENT setting in the database to retrieve a new value
					for the primary key on insert.
					The key is usually declared as an "<literal>unsigned int</literal>" in the database.
				</para>
				
				<note>
					If the property which contain the primary key has a value, it will be overwritten
					with the new value when the object is inserted.
				</note>
				
				<para>
					This is the default setting.
				</para>
				
				<example>
					<title>Adding an AUTO_INCREMENT primary key</title>
					
					<programlisting language="php"><![CDATA[class FooDescriptor extends Db_Descriptor
{
	public function __construct()
	{
		// ...
		// self can be used in this case instead of Db_Descriptor
		$this->add($this->newPrimaryKey('id')->setPkType(self::AUTO_INCREMENT));
		// ...
	}
}]]></programlisting>
				</example>
				
				<warning>
					Only one key per table can be declared as AUTO_INCREMENT as the database have a restriction
					of one AUTO_INCREMENT column per table.
				</warning>
			</section>
			
			<section>
				<title>Db_Descriptor::MANUAL</title>
				
				<para>
					This type enables the manual control of the primary key value.
					Because of this, it does not really matter what type the primary key has in the database.
				</para>
				
				<warning>
					<para>
						You have to assert that the primary key is unique before inserting,
						RapidDataMapper does not do checks for existing primary keys.
					</para>
					
					<para>
						(It is, however, possible with identical primary keys if they are part of a composite
						with multiple primary keys, provided that the combination of them all is unique.)
					</para>
				</warning>
				
				<example>
					<title>Adding and using a manually set primary key</title>
					
					<programlisting language="php"><![CDATA[class FooDescriptor extends Db_Descriptor
{
	public function __construct()
	{
		// ...
		$this->add($this->newPrimaryKey('name')->setPkType(self::MANUAL));
		// ...
	}
}

// usage:

$o = new Foo();
// ...

// set primary key:
$o->name = 'This is some name';

Db::save($o);

echo $o->name; // This is some name]]></programlisting>
				</example>
				
				<note>
					If the primary key property is missing a value, an <classname>Db_Exception</classname> exception
					will be thrown when <function>Db::save</function> attempts to save the object.
				</note>
			</section>
		</section>
		
		<section>
			<title>Multi-Primary key support</title>
			
			<para>
				RapidDataMapper has full support for multiple primary keys per table.
				The only thing you have to do is to add two or more <classname>Db_Descriptor_PrimaryKey</classname>
				instances to the descriptor.
			</para>
			
			<example>
				<title>Using multiple primary keys with RapidDataMapper</title>
				
				<programlisting language="php"><![CDATA[class FooDescriptor extends Db_Descriptor
{
	public function __construct()
	{
		// ...
		$this->add($this->newPrimaryKey('id')->setType(self::MANUAL));
		$this->add($this->newPrimaryKey('lang')->setType(self::MANUAL));
	}
}

$en = Db::find('foo', array(1, 'en')); // get English object with the id 1

$sv = new Foo(); // create a Swedish translation
$sv->id = 1;
$sv->lang = 'sv';

// ...

Db::save($sv);]]></programlisting>
			</example>
		</section>
	</section>
	
	<section>
		<title>Adding hooks to the objects</title>
		
		<para>
			TODO: MORE
		</para>
	</section>
	
	<section>
		<title>Using Plugins</title>
		
		<para>
			TODO: MORE
		</para>
	</section>
</chapter>