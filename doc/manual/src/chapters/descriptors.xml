<?xml version="1.0" encoding="utf-8"?>
<chapter
	version="5.0"
	xml:id="chapter.descriptors"
	xml:lang="en"
	xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:db="http://docbook.org/ns/docbook"
	>
	
	<title>Descriptors</title>
	
	<section>
		<title>Introduction</title>
		
		<para>
			In RapidDataMapper there are no configuration files, instead it uses <abbrev>PHP</abbrev> objects
			for storing the configuration.
			This enables a lot of customization as classes makes it possible to modify their behaviour by sub-classing.
		</para>
		
		<para>
			The objects which contain the configurations are called descriptors, this is because
			they describe the mapping.
			All descriptors are either instances of <classname>Db_Descriptor</classname>
			or instances of a descendant class.
		</para>
		
		<para>
			The <classname>Db_Descriptor</classname> class contains a lot of default values and assumptions,
			some of them are modifiable by changing properties or calling methods,
			others are modifiable by overriding one or several methods in a child class.
			This not only enables a user to have a simple and powerful way to configure a mapping,
			it also enables the user to create his own default descriptor settings with a subclass which
			is then used as the base class for his descriptors.
		</para>
		
	</section>
	
	<section xml:id="chapter.descriptors.associating">
		<title>Associating descriptors with the class to be mapped</title>
		
		<para>
			There are several ways to add descriptors, which one that is suitable depends on your preferences
			and how the project is set up (<glossterm>autoloaders</glossterm>, configuration files,
			folder structure <abbrev>etc</abbrev>.).
		</para>
		
		<para>
			All loaded descriptors are stored in an internal array, which means that once a descriptor
			is loaded, that instance is the descriptor for that class permanently (until the restart of the PHP
			thread running, so the static <classname>Db</classname> class is reloaded).
		</para>
		
		<para>
			If all tries to load a descriptor fails, a <classname>Db_Exception_MissingDescriptor</classname>
			is thrown.
		</para>
		
		<para>
			Here are the different methods of associating a class as the <glossterm>descriptor</glossterm> for a class
			to be mapped (ordered after precedence, RapidDataMapper tries to find a descriptor using the first
			listed method and then the second and so on):
		</para>
		
		<section>
			<title>Using Db::addDescriptor</title>
			
			<para>
				This method is suitable when you eg. generate a descriptor on the fly
				(ie. creating an instance of <classname>Db_Descriptor</classname> and then configure it
				for the mapping) or want to make another descriptor class take precedence over another
				which would be loaded by any of the other methods (eg. you need a special variant of the
				descriptor. NOTE: This requires the <function>Db::compileMappers</function> setting to
				be set to <symbol>false</symbol> as there can only be one compiled mapper instance per
				class to map.).
			</para>
			
			<para>
				<function>Db::addDescriptor</function> takes a <classname>Db_Descriptor</classname>
				instance and adds it to the internal array of descriptors.
				The <function>Db::getDescriptor</function> method always checks this array first
				to get the descriptor for the descriptor instance, which makes this method
				(<function>Db::addDescriptor</function>) have the highest precedence.
				The descriptors in this array are assigned by which class name they map
				(ie. what <function>Db_Descriptor->getClass</function> says it maps).
			</para>
			
			<para>
				If a class already has a loaded descriptor instance, <function>Db::addDescriptor</function>
				will throw a <classname>RuntimeException</classname>.
			</para>
			
			<funcsynopsis xml:id="funcref.Db-addDescriptor">
				<funcprototype>
					<funcdef><type>void</type> <function>Db::addDescriptor</function></funcdef>

					<paramdef><type>Db_Descriptor</type> <parameter>$descriptor</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
			
			<example>
				<title>Creating and assigning a descriptor on the fly</title>
				
				<programlisting language="php"><![CDATA[$d = new Db_Descriptor();

$d->setClass('Foobar');

$d->add($d->newPrimaryKey('id'));

foreach($columns as $c)
{
	$d->add($d->newColumn($c));
}

Db::addDescriptor($d);

$f = Db::find('Foobar')->get();]]></programlisting>
			</example>
		</section>
		
		<section>
			<title>Using a callback to return the appropriate descriptor</title>
			
			<para>
				This method uses a <glossterm>callback</glossterm> to fetch the proper descriptor instance.
			</para>
			
			<para>
				See chapter <link linkend="chapter.alternatives_to_the_db_descriptor">Alternatives to the Db_Descriptor</link>
			</para>
			
			<example>
				<title>Using XML configurations as the descriptors</title>
				
				<para>
					Firstly, create a directory for the configuration files
					(somewhere suitable, where PHP can read the files).
					Then add XML configuration files in that directory,
					for their format and naming, check
					<link linkend="chapter.alternatives_to_the_db_descriptor.xml">Alternatives to the Db_Descriptor: XML</link>.
				</para>
				
				<programlisting language="php"><![CDATA[// this is hypothetical syntax, as the Db_DescriptorLoader_*
// classes still needs to be written:

Db::setDescriptorLoader(array(new Db_DescriptorLoader_Xml('path/to/config/dir'), 'getDescriptor'));

// try to fetch an object which is described by an XML file
$o = Db::find('Foobar')->getOne();]]></programlisting>
			</example>
		</section>
		
		<section>
			<title>Using a class named classname + "<literal>Descriptor</literal>"</title>
			
			<para>
				This will probably be the most common method of loading the descriptors, which is to be
				used when using an <glossterm>autoloader</glossterm> to fetch the classes which are
				to be mapped.
				It makes it easy, as the descriptors will be stored in the same directory as the
				classes they map.
				Their filename will also be almost identical to the filename that they map, with
				the addition of "<literal>Descriptor</literal>" before the "<literal>.php</literal>"
				(depends on the autoloader).
			</para>
			
			<para>
				<function>Db::getDescriptor</function> tries to see if the class exists, and also
				tries to autoload it (by using <function>class_exists</function>).
				If the class is found, an instance is created and then used as the descriptor for the
				class to map.
			</para>
			
			<example>
				<title>Using class names to assign descriptors</title>
				
				<programlisting language="php"><![CDATA[// Preferably, this class should be defined in a separate file which is autoloaded.
// It makes for less loaded files when using compiled mappers (because the descriptors aren't needed).
class FoobarDescriptor extends Db_Descriptor
{
	public function __construct()
	{
		$this->setClass('Foobar');
		
		$this->add($this->newPrimaryKey('id'));
		$this->add($this->newColumn('title'));
		// ...
	}
}

echo Db::find('Foobar')->count();]]></programlisting>
			</example>
		</section>
		
		<section>
			<title>Using the Db::setDescriptorDirectory to load PHP files from a directory</title>
			
			<para>
				This method will probably be used in projects which does not use an <glossterm>autoloader</glossterm>,
				mainly because it fits more with their style: defining directories to contain specific files,
				classes and helper methods and then loading them with the help of <function>file_exists</function>
				and <function>include</function>.
			</para>
			
			<para>
				This is what <function>Db::getDescriptor</function> does if it cannot find a class with any of
				the above mentioned methods; tries to find a file with the same name as the class
				(+ "<literal>.php</literal>") and if the file exists: <function>require</function>s it and then
				tries to instantiate a class with the name of classname + "<literal>Descriptor</literal>".
			</para>
			
			<para>
				Use <function linkend="funcref.Db-setDescriptorDirectory">Db::setDescriptorDirectory</function>
				to set the path to the folder which contain the files with the descriptors.
			</para>
		</section>
	</section>
	
	<section>
		<title>Getting the descriptor which is mapped to a certain class</title>
		
		<para>
			To see which descriptor instance that a certain class is using for the mapping,
			use the <function>Db::getDescriptor</function>.
			This method will return a loaded descriptor instance, and if it isn't,
			it will try to load it with the steps shown in the section above.
		</para>
		
		<funcsynopsis xml:id="funcref.Db-getDescriptor">
			<funcprototype>
				<funcdef><type>Db_Descriptor</type> <function>Db::getDescriptor</function></funcdef>
				
				<paramdef><type>string</type> <parameter>$class_name</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
		
		<para>
			If a descriptor is not found, a <classname>Db_Exception_MissingDescriptor</classname>
			will be thrown.
		</para>
		
		<example>
			<title>Checking if a class has a descriptor, and if so, which table the class is mapped to</title>
			
			<programlisting language="php"><![CDATA[try
{
	$d = Db::getDescriptor('Foobar');
	
	echo sprintf('Class Foobar is mapped to the table %s.', $d->getTable());
}
catch(Db_Exception_MissingDescriptor $e)
{
	echo sprintf('Failed to get a descriptor for the class %s', $e->getClassName());
}]]></programlisting>
		</example>
	</section>
	
	<section>
		<title>Mapping classes to tables</title>
		
		<para>
			First, you create an instance of Db_Descriptor; either a subclass or a normal instance which
			you then send to <function linkend="funcref.Db-addDescriptor">Db::addDescriptor</function>.
			This instance needs to know which class it describes, otherwise it is useless,
			which is set using the <function>Db_Descriptor->setClass</function> method:
		</para>
		
		<funcsynopsis xml:id="funcref.Db_Descriptor-setClass">
			<funcprototype>
				<funcdef><type>Db_Descriptor</type> <function>Db_Descriptor->setClass</function></funcdef>
				
				<paramdef><type>string</type> <parameter>$class_name</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
		
		<para>
			(This method, an many other methods of the <classname>Db_Descriptor</classname> supports
			<glossterm>method-chaining</glossterm>.)
		</para>
		
		<para>
			By default is the class attribute used as a base for the following settings:
			singular name (name used to refer to the class in singular, eg.
			<link linkend="chapter.relations">Relations</link> and their foreign keys),
			table name, and finally factory (the code piece which is used to create a new instance of the class when
			fetching data. All these values are constructed from the value supplied to
			<function>Db_Descriptor->setClass</function> and can be changed;
			either through their setters or through replacing their getter methods.
		</para>
		
		<table>
			<title>Class - Table mapping settings</title>
			
			<tgroup cols="5">
				<thead>
					<row>
						<entry>Name</entry>
						<entry>Setter</entry>
						<entry>Getter</entry>
						<entry>Default</entry>
						<entry>Description</entry>
					</row>
				</thead>
				
				<tbody>
					<row>
						<entry>class</entry>
						<entry><function>setClass</function>(<type>string</type> <parameter>$class_name</parameter>)</entry>
						<entry><type>string</type> <function>getClass</function>()</entry>
						<entry>REQUIRED</entry>
						<entry>
							The class name the current descriptor describes.
						</entry>
					</row>
					
					<row>
						<entry>singular</entry>
						<entry><function>setSingular</function>(<type>string</type> <parameter>$singular</parameter>)</entry>
						<entry><type>string</type> <function>getSingular</function>()</entry>
						<entry>lowercase of classname</entry>
						<entry>
							The name which is use to refer to the class in a singular fashion in queries and
							also used as a base for the relations' foreign keys
						</entry>
					</row>
					
					<row>
						<entry>table</entry>
						<entry><function>setTable</function> (<type>string</type> <parameter>$table</parameter>)</entry>
						<entry><type>string</type> <function>getTable</function>()</entry>
						<entry>plural of the singular setting</entry>
						<entry>
							The table name of the database table to which the class should be mapped to.
						</entry>
					</row>
					
					<row>
						<entry>factory</entry>
						<entry><function>setFactory</function> (<type>string</type> <parameter>$factory</parameter>)</entry>
						<entry><type>string</type> <function>getFactory</function>()</entry>
						<entry>"<literal>new</literal> " + class name</entry>
						<entry>
							The code piece to add after an equal sign ("<literal>=</literal>") but before the
							semicolon ("<literal>;</literal>") which is used to create a new object instance.
						</entry>
					</row>
					
					<row>
						<entry>database connection name</entry>
						<entry><function>setConnectionName</function> (<type>string</type> <parameter>$connection_name</parameter>)</entry>
						<entry><type>string</type> <function>getConnectionName</function>()</entry>
						<entry>
							"" (ie. the default database connection or if a connection has been specified by
							<function>setConnection</function>, that is used.
						</entry>
						<entry>
							The database connection to which the class should be mapped.
						</entry>
					</row>
					
					<row>
						<entry>database connection</entry>
						<entry><function>setConnection</function> (<type>Db_Connection</type> <parameter>$connection_object</parameter>)</entry>
						<entry><type>Db_Connection</type> <function>getConnection</function>()</entry>
						<entry>
							Default connection or the connection specified by <function>setConnectionName</function>.
						</entry>
						<entry>
							The <classname>Db_Connection object</classname> to use when mapping the
							class to the database.
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
		
		<para>
			As listed in the table; it is also possible to map the classes to several different connections.
		</para>
		
		<para>
			It is not always that the <classname>Db_Inflector</classname> can pluralize the singular name properly.
			If that is the case (you can easily see this by testing with
			"<literal>echo Db::getDescriptor('class name')->getTable();</literal>"),
			then use <function>Db_Descriptor->setTable</function> to set the correct table name.
		</para>
		
		<example>
			<title>Adjusting singular, table name and factory of table mappings</title>
			
			<programlisting language="php"><![CDATA[// We're doing it the short way, to easily show how it works
$d = new Db_Descriptor();

// Exceptions are thrown when class is not set:
// $d->getClass();
// $d->getSingular();
// $d->getTable();
// $d->getFactory();

$d->setClass('Track_obj');

echo $d->getClass();    // Track_obj
echo $d->getSingular(); // track_obj
echo $d->getTable();    // track_objs
echo $d->getFactory();  // new Track_obj

$d->setSingular('track');

echo $d->getClass();    // Track_obj
echo $d->getSingular(); // track
echo $d->getTable();    // tracks
echo $d->getFactory();  // new Track_obj

$d->setTable('track_tbl');

echo $d->getClass();    // Track_obj
echo $d->getSingular(); // track
echo $d->getTable();    // track_tbl
echo $d->getFactory();  // new Track_obj

$d->setFactory('Track_obj::create()');

echo $d->getClass();    // Track_obj
echo $d->getSingular(); // track
echo $d->getTable();    // track_tbl
echo $d->getFactory();  // Track_obj::create()]]></programlisting>
		</example>
	</section>
	
	<section>
		<title>Mapping properties to columns</title>
		
		<para>
			TODO: MORE
		</para>
	</section>
	
	<section>
		<title>Using Plugins</title>
		
		<para>
			TODO: MORE
		</para>
	</section>
</chapter>