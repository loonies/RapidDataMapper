<?php
/*
 * Created by Martin Wernståhl on 2010-07-04.
 * Copyright (c) 2010 Martin Wernståhl.
 * All rights reserved.
 */

/**
 * Class which manages the Rdm_Collection classes and their code.
 */
final class Rdm_CollectionManager
{
	/**
	 * A list of collection names and their dependencies.
	 * 
	 * @var array(string => array)
	 */
	static protected $dependencies = array();
	
	/**
	 * The object determining the order in which unit of works should run their
	 * operations.
	 * 
	 * @var Rdm_UnitOfWork_CommitOrderCalculator
	 */
	static protected $commit_order_calculator = null;
	
	// ------------------------------------------------------------------------
	
	/**
	 * Initializes the RapidDataMapper ORM.
	 * 
	 * @param  boolean  If to register the Rdm_Collection::pushChanges() method to
	 *                  run on shutdown.
	 * @return void
	 */
	public static function init($auto_push = true)
	{
		spl_autoload_register('Rdm_CollectionManager::autoload');
		
		$auto_push && register_shutdown_function('Rdm_CollectionManager::pushChanges');
	}
	
	// ------------------------------------------------------------------------

	/**
	 * Loads the specific collection classes for entity objects, pattern of their
	 * classnames are <EntityClass>Collection or <EntityClass>CollectionBase.
	 * 
	 * @param  string
	 * @return boolean
	 */
	public static function autoload($class)
	{
		if(substr($class, -10) !== 'Collection' && substr($class, -14) !== 'CollectionBase')
		{
			return false;
		}
		
		// Remove "Base" if present
		if(substr($class, -4) === 'Base')
		{
			$class = substr($class, 0, -4);
		}
		
		// Check for a cached file
		if(Rdm_Config::getCacheMappers())
		{
			$dir = Rdm_Config::getMapperCacheDir();
			
			if(file_exists($dir.DIRECTORY_SEPARATOR.$class.'.php'))
			{
				include $dir.DIRECTORY_SEPARATOR.$class.'.php';
				
				if(class_exists($class))
				{
					return true;
				}
			}
		}
		
		// Remove "Collection"
		$entity_class = substr($class, 0, -10);
		
		$desc = Rdm_Config::getDescriptor($entity_class);
		
		try
		{
			// Build the new class
			$builder = $desc->getBuilder();
		}
		catch(Exception $e)
		{
			// Handle errors, we cannot just let exceptions pass through,
			// because then autoload falls back on the other autoloaders
			// and ignores our exception
			
			// Call the exception handler directly instead
			
			// Get the exception handler, use this method as an impostor so
			// we can convince PHP to lend us the current exception handler
			$eh = set_exception_handler(array(__CLASS__, 'autoload'));
			// We must kill the impostor before he is found out!
			restore_exception_handler();
			
			if( ! $eh)
			{
				// We got a fake!
				
				// Now we have to try to fool the buyer...
				self::triggerExceptionError($e);
			}
			else
			{
				// Now we execute the stolen handler!
				call_user_func($eh, $e);
			}
			
			// Let's leave before it blows up!
			exit;
		}
		
		// Do we write a compiled file?
		if(Rdm_Config::getCacheMappers())
		{
			// write the precompiled file
			$res = @file_put_contents(Rdm_Config::getMapperCacheDir().'/'.$class.'.php', '<?php
/*
 * Generated by RapidDataMapper on '.date('Y-m-d H:i:s').'.
 * 
 * Copyright (c) 2010 Martin Wernståhl.
 * All rights reserved.
 */

'.$builder->__toString());
			
			// did the write work?
			if( ! $res)
			{
				// we need to tell the user that he needs to make the folder writable,
				// therefore he will know why it is slow
				trigger_error('RapidDataMapper: Cannot write to the "'.Rdm_Config::getMapperCacheDir().'" directory, using eval() instead.', E_USER_WARNING);
				
				// eval the code in case it didn't get written
				eval($builder->__toString());
			}
			else
			{
				require Rdm_Config::getMapperCacheDir().'/'.$class.'.php';
			}
		}
		else
		{
			eval($builder->__toString());
		}
	}
	
	// ------------------------------------------------------------------------

	/**
	 * This is a fake exception printer, it will raise a fatal error with the
	 * exception formatted as the default PHP printer.
	 * 
	 * @param  Exception
	 * @return void
	 */
	protected static function triggerExceptionError($exception)
	{
		$message = 'Uncaught exception \''.get_class($exception).'\' with message \''.$exception->getMessage().'\' in '.$exception->getFile().'::'.$exception->getLine().'
Stack trace:
'.$exception->getTraceAsString().'
  thrown in '.$exception->getFile().' on line '.$exception->getLine().'
  faked';
		
		// Trigger the error
		trigger_error($message, E_USER_ERROR);
	}
	
	// ------------------------------------------------------------------------

	/**
	 * Registers a class name as a collection object, used by pushChanges() to
	 * get all collections' unit of work objects.
	 * 
	 * @param  string
	 * @param  array   A list of entity class names which $class_name depends on
	 * @return void
	 */
	public static function registerCollectionClassName($class_name, array $dependencies = array())
	{
		self::$dependencies[$class_name] = $dependencies;
	}
	
	// ------------------------------------------------------------------------

	/**
	 * Pushes all changes to the database.
	 * 
	 * @return void
	 */
	public static function pushChanges()
	{
		// TODO: How to do with multiple database connections?
		$db = Rdm_Adapter::getInstance();
		$units = array();
		
		if(empty(self::$commit_order_calculator))
		{
			self::$commit_order_calculator = new Rdm_UnitOfWork_CommitOrderCalculator(self::$dependencies);
		}
		else
		{
			// Update the dependencies
			self::$commit_order_calculator->dependencies = self::$dependencies;
		}
		
		// Get the unit of works from the loaded collections
		foreach(self::$commit_order_calculator->calculate() as $c)
		{
			$units[] = call_user_func($c.'::getUnitOfWork');
		}
		
		if($db->transactionInProgress())
		{
			// We already have a transaction, do not create another
			
			self::doPushes($units);
		}
		else
		{
			// Nope, create a new local transaction
			try
			{
				$db->transactionStart();
				
				self::doPushes($units);
				
				// Done!
				$db->transactionCommit();
			}
			catch(Exception $e)
			{
				// Oops, error, reset objects now
				foreach($units as $u)
				{
					$u->reset();
				}
				
				// Rethrow
				throw $e;
			}
		}
	}
	
	// ------------------------------------------------------------------------

	/**
	 * Pushes the contents of the unit of works in the supplied list.
	 * 
	 * @param  array(Rdm_UnitOfWork)
	 * @return void
	 */
	public static function doPushes(array $units)
	{
		foreach($units as $u)
		{
			$u->doInserts();
		}
		
		foreach($units as $u)
		{
			$u->doUpdates();
		}
		
		// DELETE queries must be reversed because we need to remove the children
		// before the parent
		foreach(array_reverse($units) as $u)
		{
			$u->doDeletes();
		}
		
		// All done, now we clean up
		foreach($units as $u)
		{
			$u->cleanup();
		}
	}
}


/* End of file CollectionManager.php */
/* Location: ./lib/Rdm */